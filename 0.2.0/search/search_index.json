{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"MARCIA - MAsking spectRosCopIc dAtacube","text":""},{"location":"index.html#manual-classifier-for-xrf-and-edssem-hypercubes","title":"Manual classifier for \u00b5XRF and EDS/SEM hypercubes","text":"<ul> <li>Classification is achieved by defining masks that are linear combination of elemental intensities in spectra.</li> <li>Classes can then be extracted and read with hyperspy or PyMca or Esprit</li> </ul>"},{"location":"index.html#install","title":"Install","text":"<p>Just do <pre><code>pip install marcia\n</code></pre></p>"},{"location":"index.html#use-in-python","title":"Use in python","text":"<pre><code>import marcia as mc\n</code></pre>"},{"location":"index.html#gallery","title":"Gallery","text":""},{"location":"marcia_install.html","title":"Install MARCIA","text":"<p>Note</p> <p>The complete use of MARCIA reaquires the installation of HyperSpy. It is a package designed for the use of multispectral data, also called datacube.</p>"},{"location":"marcia_install.html#install-using-pypi","title":"Install using Pypi","text":"<pre><code>pip install marcia\n</code></pre>"},{"location":"marcia_install.html#update-using-pypi","title":"Update using Pypi","text":"<pre><code>pip install marcia --update\n</code></pre>"},{"location":"python_install.html","title":"Python Installation","text":"<p>Marcia requires Python version &gt;= 3.7. You can directly install python or use Anaconda, which allows an easier set up and management of different working environment. Set up different working environments is highly recommend as it prevents the interferences between python versions and package (such as Marcia or PyMca) vesions.</p> Direct Installation <ul> <li>Download python: https://www.python.org/downloads/</li> <li>Set up working environment: https://docs.python.org/3.8/library/venv.html#module-venv</li> </ul> Using Anaconda <ul> <li>Download Anaconda: https://www.anaconda.com/products/individual</li> <li>Set up working environment: https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-with-commands</li> </ul>"},{"location":"code_reference/data_io.html","title":"Datacube","text":""},{"location":"code_reference/data_io.html#marcia.io.datacube.load","title":"<code>load</code>","text":"<p>Create a 3D array (X and Y are the dimensions of the sample and Z dimension is the number of elements/emission lines taken into account for the classification).</p> <p>Stack the information contained in the elemental files given ranked according to the spreasheet ranking.</p> <p>If normalization is asked or if the elemental map is an image file, data in the array are between 0 and 100.</p> <p>Three types of elemental files are accepted</p> <ul> <li> <p>Imges (.bmp of .tif), which are RGB files : each pixel contains 3 values between 0 and 255. The rgb is put into greyscale calculated by the norm 2.</p> </li> <li> <p>Textfile (.txt), which is already the elemental array where the values are the number of counts.</p> </li> <li> <p>Raw file (.rpl), wich is the datacube containing all the spectra for every pixel. The hyperspy library is used to extract the emission lines corresponding to the wanted elements.</p> </li> </ul> <p>Textfiles and raw files can be normalized or not, the spreadsheet must be written according to that.</p> <p>The function also creates a dictionnary containing the Z position of the element in the 3D array created.</p> <p>2 class files created in that function.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Common name between files.</p> required <code>suffix</code> <code>str</code> <p>Extension name of the files.</p> required <code>normalization</code> <code>bool</code> <p>If data are normalized between 0 and 100.</p> <code>True</code> <code>element_list</code> <code>List[str]</code> <p>User can specify list  elements to be taken, or let the program finds all data in corresponding to given prefix name.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If given extension is not accepted by the program.</p>"},{"location":"code_reference/data_io.html#marcia.io.datacube.load_images","title":"<code>load_images</code>","text":"<p>Images Data loader. </p> <p>Low-level function for data loading.</p> <p>Parameters:</p> Name Type Description Default <code>file_list</code> <code>List[str]</code> <p>List of images files to load.</p> required <code>prefix</code> <code>str</code> <p>Common name between files.</p> required <code>suffix</code> <code>str</code> <p>Extension name of the files.</p> required <p>Returns:</p> Type Description <code>MultiCube</code> <p>Marcia MultiCube Objects.</p> <code>MultiCube</code> <p>MultiCube means data channels are discrete and not continuous.</p>"},{"location":"code_reference/data_io.html#marcia.io.datacube.load_textfile","title":"<code>load_textfile</code>","text":"<p>Text Data Loader.</p> <p>Low-level function for data loading.</p> <p>Parameters:</p> Name Type Description Default <code>file_list</code> <code>List[str]</code> <p>List of images files to load.</p> required <code>prefix</code> <code>str</code> <p>Common name between files.</p> required <code>suffix</code> <code>str</code> <p>Extension name of the files.</p> required <code>normalization</code> <code>bool</code> <p>If data are normalized between 0 and 100.</p> <code>True</code> <p>Returns:</p> Type Description <code>MultiCube</code> <p>Marcia MultiCube Objects.</p> <code>MultiCube</code> <p>MultiCube means data channels are discrete and not continuous.</p>"},{"location":"code_reference/data_io.html#marcia.io.datacube.load_hypermap","title":"<code>load_hypermap</code>","text":"<p>Raw HyperCube Data Loader.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Name of file.</p> required <code>suffix</code> <code>str</code> <p>Extension name of the file.</p> required <code>name</code> <code>str</code> <p>Physical measure of channel</p> <code>'E'</code> <code>units</code> <code>str</code> <p>Unit of physical measure. Defaults to 'keV'.</p> <code>'keV'</code> <code>scale</code> <code>float</code> <p>Scale realationship betwen channel and physical measure.</p> <code>0.01</code> <code>offset</code> <code>float</code> <p>Scale offset between channel and physcial measure.</p> <code>-0.97</code> <p>Returns:</p> Type Description <code>HyperCube</code> <p>Marcia HyperCube Object.</p> <code>HyperCube</code> <p>HyperCube means data channels are continuous.</p>"},{"location":"code_reference/data_io.html#marcia.io.datacube.save","title":"<code>save</code>","text":"<p>Save specified element as a .tif image file.</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>element</code> <code>str</code> <p>Name of the wanted element (eg: 'Fe')</p> required <code>raw</code> <code>bool</code> <p>If saved image has information background or not.</p> <code>False</code>"},{"location":"code_reference/data_io.html#marcia.io.datacube.save_cube_inside_mask","title":"<code>save_cube_inside_mask</code>","text":"<p>Recreates raw datacube containing data only in the wanted element.</p> <p>Parameters:</p> Name Type Description Default <code>data_cube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>mineral</code> <code>str</code> <p>Name of the wanted element (eg: 'Galene')</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If raw data cube is not in folder.</p>"},{"location":"code_reference/data_io.html#marcia.io.datacube.save_cube_outside_mask","title":"<code>save_cube_outside_mask</code>","text":"<p>Recreates a raw datacube containing data that  are not in the specified element.</p> <p>Parameters:</p> Name Type Description Default <code>data_cube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>mineral</code> <code>str</code> <p>Name of the wanted element (eg: 'Galene')</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If raw data cube is not in folder.</p>"},{"location":"code_reference/data_io.html#marcia.io.datacube.save_mask_spectrum","title":"<code>save_mask_spectrum</code>","text":"<p>Save mean spectrum of a given mask as a .txt file.</p> <ul> <li>First column is channel.</li> <li>Second column is counts.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data_cube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>mask</code> <code>str</code> <p>Name of the wanted mask (eg: 'Galene').</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If raw data cube is not in folder.</p>"},{"location":"code_reference/datacube.html","title":"Datacube","text":""},{"location":"code_reference/datacube.html#marcia.core.datacube.DataCube","title":"<code>DataCube</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base Class Object for datacube. Considered as abstract parent class.</p> <p>Attributes:</p> Name Type Description <code>datacube</code> <code>ndarray</code> <p>multi-dimensionnal array containing data values.</p> <code>prefix</code> <code>str</code> <p>Common name between files.</p> <code>suffix</code> <code>str</code> <p>Extension name of the files.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.DataCube.datacube","title":"<code>datacube: np.ndarray</code>  <code>property</code>","text":"<p>Return data values as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3 dimensionnal numpy array.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.DataCube.prefix","title":"<code>prefix: str</code>  <code>property</code>","text":"<p>Return prefix.</p> <p>Returns:</p> Type Description <code>str</code> <p>prefix name.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.DataCube.suffix","title":"<code>suffix: str</code>  <code>property</code>","text":"<p>Return suffix.</p> <p>Returns:</p> Type Description <code>str</code> <p>suffix name.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.MultiCube","title":"<code>MultiCube</code>","text":"<p>             Bases: <code>DataCube</code></p> <p>MultiCube Object. MultiCube class is made for discrete datacube such as multispectral satellite data of stack of elemental images.</p> <p>Attributes:</p> Name Type Description <code>data_cube</code> <code>ndarray</code> <p>multi-dimensionnal array containing data values.</p> <code>elements</code> <code>Dict</code> <p>Dictionnary of channel names with associated index.</p> <code>prefix</code> <code>str</code> <p>Common name between files.</p> <code>suffix</code> <code>str</code> <p>Extension name of the files.</p> <code>normalization</code> <code>bool</code> <p>Indication of normalized data (0 to 100).</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.MultiCube.elements","title":"<code>elements: Dict</code>  <code>property</code>","text":"<p>Returns elements dictionnary.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Keys are indices and values are element names.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.MultiCube.normalization","title":"<code>normalization: bool</code>  <code>property</code>","text":"<p>Returns Normalization parameters.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if Normalized, False else.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.MineralCube","title":"<code>MineralCube</code>","text":"<p>             Bases: <code>MultiCube</code></p> <p>MineralCube Object. MultiCube object where values are binary (0 or 1).</p> <p>Class essentially made to create mask and make operations between data and masks.</p> <p>Attributes:</p> Name Type Description <code>data_cube</code> <code>ndarrray</code> <p>multi-dimensionnal array containing data values.</p> <code>elements</code> <code>Dict</code> <p>Dictionnary of channel names with associated index.</p> <code>prefix</code> <code>str</code> <p>Common name between files.</p> <code>suffix</code> <code>str</code> <p>Extension name of the files.</p> <code>normalization</code> <code>(bool, Optional)</code> <p>Indication of normalized data (0 to 100).</p> <code>colors</code> <code>List</code> <p>Color list provided for plotting consistency.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.MineralCube.colors","title":"<code>colors: List</code>  <code>property</code>","text":"<p>Returns colors lists.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of colors for plotting purposes.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.MineralCube.map","title":"<code>map</code>","text":"<p>Create a 2D array that associate each pixel to a mask by assigning a value to each pixel. It also creates a dictionnary containing the relative proportion of a value compared to others.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple containing 2D array to be used as an image, </p> <code>Dict</code> <p>and dictionnary containing proportion of each pixel value.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.HyperCube","title":"<code>HyperCube</code>","text":"<p>             Bases: <code>DataCube</code></p> <p>HyperCube Object. HyperCube class is made for continuous datacube such as hyperspecral satellite data or hyperspectral datacube from MicroXRF or EPMA analyses.</p> <p>Attributes:</p> Name Type Description <code>data_cube</code> <code>tbd</code> <p>HyperSpy object.</p> <code>prefix</code> <code>str</code> <p>Filename.</p> <code>suffix</code> <code>str</code> <p>File extension.</p>"},{"location":"code_reference/datacube.html#marcia.core.datacube.HyperCube.normalization","title":"<code>normalization: bool</code>  <code>property</code>","text":"<p>Returns Normalization parameters.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if Normalized, False else.</p>"},{"location":"code_reference/manual_fit.html","title":"Manual Fitting","text":""},{"location":"code_reference/manual_fit.html#marcia.fitting.manual_fit.mineralcube_creation","title":"<code>mineralcube_creation</code>","text":"<p>Create a 3D numpy array (X and Y are the dimensions of the sample and Z dimension is the number of minerals wanted for the classification). Minerals are defined by the columns in the mask table. The 2D array created per mineral depends on the threshold specified in the mask table. If one value is given, it corresponds to the minimum threshold to be in the mineral. If two values separated by a dash, it corresponds to the range of values for this element to be in the mineral (threshold are exclusive).</p> <p>Each mineral array is binary with 1 where the pixel is in the mineral and NaN (not assigned value) where the pixel is not in the mineral.</p> <p>The function also creates a dictionnary containing the Z position of the minerals in the 3D array created.</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>MultiCube</code> <p>Marcia DataCube Object to be classify.</p> required <code>mask</code> <code>Mask</code> <p>Marcia Mask Object containing thresholds for manual classification.</p> required <p>Returns:</p> Type Description <code>MineralCube</code> <p>Marcia Mineralube Object containing binary values.</p>"},{"location":"code_reference/mask.html","title":"Mask","text":""},{"location":"code_reference/mask.html#marcia.core.mask.Mask","title":"<code>Mask</code>","text":"<p>Mask Fitter Class Mask class is made for manual fitting of DataCube.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>DataFrame</code> <p>Table to extract thresholds  for manual fitting.</p> <code>colors</code> <code>List</code> <p>Color List for plotting consistency.</p> <code>filename</code> <code>str</code> <p>Filename of table.</p>"},{"location":"code_reference/mask.html#marcia.core.mask.Mask.table","title":"<code>table: pd.DataFrame</code>  <code>property</code> <code>writable</code>","text":"<p>Returns pandas table.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame of thresholds values.</p>"},{"location":"code_reference/mask.html#marcia.core.mask.Mask.masks","title":"<code>masks: List</code>  <code>property</code>","text":"<p>Returns list of mask names.</p> <p>Returns:</p> Type Description <code>List</code> <p>Names of user defined masks.</p>"},{"location":"code_reference/mask.html#marcia.core.mask.Mask.filename","title":"<code>filename: str</code>  <code>property</code>","text":"<p>Returns Filename.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of file.</p>"},{"location":"code_reference/mask.html#marcia.core.mask.Mask.colors","title":"<code>colors: List</code>  <code>property</code>","text":"<p>Returns colors list.</p> <p>Returns:</p> Type Description <code>List</code> <p>User defined colors for each mask.</p>"},{"location":"code_reference/mask.html#marcia.core.mask.Mask.set_value","title":"<code>set_value</code>","text":"<p>Change value of threshold for a defined mask.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Element from Mask to be change updated.</p> required <code>mask</code> <code>str</code> <p>Mask to be updated.</p> required <code>value</code> <code>str</code> <p>Value to be set.</p> required"},{"location":"code_reference/mask.html#marcia.core.mask.Mask.get_value","title":"<code>get_value</code>","text":"<p>Get value of threshold for a defined mask.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Element from Mask to be change updated.</p> required <code>mask</code> <code>str</code> <p>Mask to be updated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Threshold value.</p>"},{"location":"code_reference/mask_io.html","title":"Mask","text":""},{"location":"code_reference/mask_io.html#marcia.io.mask.load_mask","title":"<code>load_mask</code>","text":"<p>Load table file into the programm. Verification if information of colors are required for the classification. Colors are also specified in the spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the table file.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If table file format is not  supported by the program.</p> <p>Returns:</p> Type Description <code>Mask</code> <p>Marcia Mask Object.</p>"},{"location":"code_reference/plotting.html","title":"Datacube","text":""},{"location":"code_reference/plotting.html#marcia.plotting.datacube.hist_in_mask","title":"<code>hist_in_mask</code>","text":"<p>Plot elemental map and histogram associated only for a specific element in a mineralcube.</p> <p>Parameters:</p> Name Type Description Default <code>data_cube</code> <code>DataCube</code> <p>DataCube to plot.</p> required <code>mineral_cube</code> <code>MineralCube</code> <p>MineralCube to check if element in mineral.</p> required <code>element</code> <code>str</code> <p>Name of the wanted element (eg: 'Fe').</p> required <code>mineral</code> <code>str</code> <p>Name of the wanted mask (eg: 'Galene').</p> required Note <p>Does not work if datacube is HyperCube (yet).</p>"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.hist","title":"<code>hist</code>","text":"<p>Plot elemental map and histogram of a specific element.</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>indice</code> <code>str</code> <p>Element to plot.</p> required"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.datacube_hist","title":"<code>datacube_hist</code>","text":"<p>Plot the elemental map on the left side an the corresponding hitogram of intensity on the right side Input is the index of the element in the 3D array Useful function in order to set the threshold in the spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>indice</code> <code>str</code> <p>Element to plot.</p> required"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.mineralcube_hist","title":"<code>mineralcube_hist</code>","text":"<p>Plot the elemental map on the left side an the corresponding hitogram of probability to  be in the mineral on the right side. Input is the index of the element in the 3D array Useful function in order to set the threshold in the spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>mineral_cube</code> <code>MineralCube</code> <p>Marcia DataCube Object.</p> required <code>indice</code> <code>str</code> <p>Element to plot.</p> required"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.plot","title":"<code>plot</code>","text":"<p>Plot the mineral mask wanted Input is the index of the mineral in the 3D array (cube).</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>indice</code> <code>str</code> <p>Element to plot.</p> required"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.biplot","title":"<code>biplot</code>","text":"<p>Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>indicex</code> <code>str</code> <p>Element to plot on x-axis.</p> required <code>indicey</code> <code>str</code> <p>Element to plot on y-axis.</p> required"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.triplot","title":"<code>triplot</code>","text":"<p>Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>DataCube</code> <p>Marcia DataCube Object.</p> required <code>indicex</code> <code>str</code> <p>Element to plot on x-axis.</p> required <code>indicey</code> <code>str</code> <p>Element to plot on y-axis.</p> required <code>indicez</code> <code>str</code> <p>Element to color data with.</p> required"},{"location":"code_reference/plotting.html#marcia.plotting.datacube.plot_minerals","title":"<code>plot_minerals</code>","text":"<p>For mineralogy purposes, valid only if all masks are minerals Plot all the mask onto one picture in order to visualize the classification. Each pixel correspond to only one mineral at the time, if not, it is classified as \"mixed\".</p> <p>Parameters:</p> Name Type Description Default <code>datacube</code> <code>MineralCube</code> <p>Marcia MineralCube Object.</p> required"},{"location":"examples/Tutorial_en.html","title":"Tutorial en","text":"<ul> <li>Elementary maps (.bmp / .tif / .jpg / .png).</li> </ul> <p>Example of elementary map : Iron (Fe).</p> <p>Elementary maps are image files and do not contain energy counts anymore. Therefore, only relative intensitivy for a same element can be used to classify pixels.</p> <ul> <li>A table with one column named \"Element\" and columns with user defined name for minerals or multi-element compound. The table is most of the time a spreadsheet: a csv file or xls file.</li> </ul> Element Galene Chalcopyrite Siderite Quartz Al As Ca Cl Cu Fe K Mg Mn Na Pb S Si Ti Color <p>Given element names must be available in the data, bein a datacube or a specific imagefile. Colors can also be provided for consistency in plotting. Colors must be specified according to the matplotlib library: https://matplotlib.org/3.1.0/gallery/color/named_colors.html</p> <p>Create a python script in the same folder as the data yo want to analyse. Then import the marcia library with the following command:</p> In\u00a0[1]: Copied! <pre>import marcia as mc\n</pre> import marcia as mc <p>Data must then be uploaded to the programm.</p> <p>Here, all .bmp files beginning with the name 'lead_ore' will be used.</p> <p>Images are stack in order to create a datacube where the first 2 dimensions are spatial dimensions of the sample and the 3rd dimension corresponds to each image provided.</p> In\u00a0[2]: Copied! <pre>data = mc.load('Data/lead_ore','.bmp')\n</pre> data = mc.load('Data/lead_ore','.bmp') <p>Classification spreadsheet must then be uploaded</p> <p>Elements in the datacube can be retrieved with the following command.</p> In\u00a0[3]: Copied! <pre>data.elements\n</pre> data.elements Out[3]: <pre>{0: 'Al',\n 1: 'As',\n 2: 'Ca',\n 3: 'Cl',\n 4: 'Cu',\n 5: 'Fe',\n 6: 'K',\n 7: 'Mg',\n 8: 'Mn',\n 9: 'Na',\n 10: 'Pb',\n 11: 'S',\n 12: 'Si',\n 13: 'Ti'}</pre> <p>Once the datacube created, each map can be displayed and analyzed in order to determine intensity clusters. For example, the following command allows to plot the intensity histogram of the Lead (Pb)</p> In\u00a0[4]: Copied! <pre>mc.hist(data,'Pb')\n</pre> mc.hist(data,'Pb') <p>We observed here a population of of pixels between 80% et 100 % of maximum intensity, probably corresponding to our only one lead-bearing mineral: Galena.</p> <p>If more than one population is visible in the histogram, stoichiometric ratio are used to assigned population to mineral.</p> <p>In general, values inferior to 5% cannot be used and correspond to the background noise.</p> <p>In the spreadsheet file we can specify the lead threshold for the Galena. As we only see one population, we can juste provide a lower threshold (5%) in order to remove the background noise.</p> <p>This value can be tuned later if classification is not accurate enough.</p> Element Galene Chalcopyrite Siderite Quartz Al As Ca Cl Cu Fe K Mg Mn Na Pb 0.05 S Si Ti Couleur <p>Classification file must then be upload in order to create the mineral classification.</p> In\u00a0[5]: Copied! <pre>mask = mc.load_mask('Data/Mask.xlsx')\n</pre> mask = mc.load_mask('Data/Mask.xlsx') <p>A new datacube of mineral is then created using the original data and the classification file. This new datacube allows to compute mineral proportion, mineral classification accuracy and extract binary mineral mask.</p> In\u00a0[6]: Copied! <pre>mineral_cube = mc.mineralcube_creation(data,mask)\n</pre> mineral_cube = mc.mineralcube_creation(data,mask) <p>Like the original datacube, the mineral can be plotted and the accuracy of the classification for each pixel can be retrieved.</p> <p>Mineral accuracy relates to the fact that a pixel might be associated to more than one mineral, which is physically impossible.</p> <p>Again, mineral list is accessible through the following command.</p> In\u00a0[7]: Copied! <pre>mineral_cube.elements\n</pre> mineral_cube.elements Out[7]: <pre>{0: 'Galene', 1: 'Chalcopyrite', 2: 'Siderite', 3: 'Quartz'}</pre> In\u00a0[8]: Copied! <pre>mc.hist(mineral_cube,'Quartz')\n</pre> mc.hist(mineral_cube,'Quartz') <p>For example, here most of the pixel accuracy is one, meaning the pixels are correctly clasiffied. But some pixels have an accuracy of 0.5. This means the pixel are classified as 2 minerals in the same time.</p> <p>Now that classes are created, we can specify querries for an element in a given mineral.</p> In\u00a0[9]: Copied! <pre>mc.hist_in_mask(data, mineral_cube, 'Pb', 'Galene' )\n</pre> mc.hist_in_mask(data, mineral_cube, 'Pb', 'Galene' ) <p>In order to verify classification, user can plot mineral map, showing a summary of the different minerals, their proportion, the proportion of misclassified pixel (pixels that are classified as more than one mineral) and the proportion of not classified (pixels that are classified as no mineral).</p> In\u00a0[10]: Copied! <pre>mc.plot_minerals(mineral_cube)\n</pre> mc.plot_minerals(mineral_cube) <p>The resulting image shows the classified mineral and its proportion. Also displayed are pixels classified into several minerals and are called mixed. The sum of the proportions of minerals and mixed compounds comes to 100%. The proportion of unindexed pixels across the entire image is also displayed. Here, this shows that 87.2% of the pixels have not yet been classified and that of the 12.8% classified, 100% correspond to galena.</p> <p>By analyzing the different histograms of the elements, it is possible to establish thresholds for the other minerals and carry out a complete classification. An example of filling out the spreadsheet is presented below. However, it is not unique and is up to the user who knows his sample and its mineralogy.</p> Element Galene Chalcopyrite Siderite Quartz Al As Ca 0.2 Cl Cu 0.9 Fe 0.9 0.05 - 0.89 K Mg Mn Na Pb 0.05 S 0.05 0.05 Si 0.7 Ti Couleur Brown Yellow"},{"location":"examples/Tutorial_en.html#detailed-example-of-classification-with-marcia-and-image-data","title":"Detailed example of classification with marcia and image data\u00b6","text":""},{"location":"examples/Tutorial_en.html#needed-files","title":"Needed Files\u00b6","text":""},{"location":"examples/Tutorial_en.html#how-to-fill-the-cells-of-the-table","title":"How to fill the cells of the table\u00b6","text":"<ul> <li>A value between 0 and 1 corresponding to relative percentage of intensity for each element</li> </ul>"},{"location":"examples/Tutorial_en.html#what-values-are-accepted","title":"What values are accepted\u00b6","text":"<ul> <li>One number, meaning corresponding class accepts only values higher than the given threshold.</li> <li>Two values separed with a dash \"-\", meaning corresponding class accepts only values comprise between the given thresholds.</li> </ul>"},{"location":"examples/Tutorial_en.html#how-to-use-marcia","title":"How To Use MARCIA\u00b6","text":""},{"location":"examples/Tutorial_fr.html","title":"Sample Classification","text":"<p>Figure 1 : Exemple de carte \u00e9l\u00e9mentaire : Fer.</p> <p>La carte est un fichier de type bitmap (.bmp), c'est-\u00e0-dire qu'elle ne contient plus les informations du nombre de coups par \u00e9nergies.</p> <p>Elle contient seulement des informations de couleur : 3 nombres entre 0 et 255 par pixels correspondant aux intensit\u00e9s RVB.</p> <ul> <li>Un tableur constitu\u00e9 d'une colonne Element et de colonnes portant le nom des masques souhait\u00e9s.</li> </ul> Element Galene Chalcopyrite Siderite Quartz Al As Ca Cl Cu Fe K Mg Mn Na Pb S Si Ti Couleur <p>Les \u00e9l\u00e9ments indiqu\u00e9s doivent \u00eatre disponibles sous forme de cartes \u00e9lementaires dans le dossier.</p> <p>Une couleur peut \u00e9galement \u00eatre sp\u00e9cifi\u00e9e lors de la cr\u00e9ation de la carte min\u00e9ralogique compl\u00e8te.</p> <p>Il suffit de cr\u00e9er une ligne appel\u00e9\u00e9 Couleur(s)/couleur(s)/Color(s)/color(s).</p> <p>Les couleurs sp\u00e9cifi\u00e9es doivent faire partie de la librairie matplotlib : https://matplotlib.org/3.1.0/gallery/color/named_colors.html</p> <p>Si les fichiers utilis\u00e9s sont de types .txt ou .raw (et .rpl associ\u00e9):</p> <p>Un rapport de deux images peut \u00e9galement \u00eatre introduit : ici F3 et F4 correspondent aux pics de diffusion    \u00e9lastique (Rayleigh diffusion) et diffusion in\u00e9lastique (Compton).</p> <p>Dans un premier temps on ouvre un script python, ou une session via un terminal.  Il faut ensuite importer la librairie marcia.</p> In\u00a0[1]: Copied! <pre>import marcia as mc\n</pre> import marcia as mc <p>Il faut ensuite charger les donn\u00e9es. Pour cela on cr\u00e9\u00e9 un cube de donn\u00e9es (3 dimensions) ou les 2 premi\u00e8res dimensions correspondent aux dimensions de l'echantillon (dimensions spatiales) et la troisi\u00e8me dimensions correspond aux informations pour chaque \u00e9l\u00e9ment disponible.</p> <p>C'est comme si les cartes \u00e9l\u00e9mentaires \u00e9taient empil\u00e9es.</p> In\u00a0[2]: Copied! <pre>data = mc.load('Data/lead_ore','.bmp')\n</pre> data = mc.load('Data/lead_ore','.bmp') <p>Il faut maintenant charger le tableur utilis\u00e9 pour faire la classification des \u00e9lements par masques. Ici les masques sont des min\u00e9raux, mais peuvent avoir une signification diff\u00e9rente selon le cas d'\u00e9tude.</p> In\u00a0[3]: Copied! <pre>mask = mc.load_mask('Data/Mask.xlsx')\n</pre> mask = mc.load_mask('Data/Mask.xlsx') <p>On obtient ainsi un cube des donn\u00e9es \u00e9l\u00e9mentaires. Pour retrouver l'index de chaque \u00e9l\u00e9ment, il suffit d'afficher le dictionnaire des indexations \u00e9l\u00e9mentaires correspondantes:</p> In\u00a0[4]: Copied! <pre>data.elements\n</pre> data.elements Out[4]: <pre>{0: 'Al',\n 1: 'As',\n 2: 'Ca',\n 3: 'Cl',\n 4: 'Cu',\n 5: 'Fe',\n 6: 'K',\n 7: 'Mg',\n 8: 'Mn',\n 9: 'Na',\n 10: 'Pb',\n 11: 'S',\n 12: 'Si',\n 13: 'Ti'}</pre> <p>Une fois ce cube cr\u00e9\u00e9, on peut \u00e9galement afficher la carte \u00e9l\u00e9mentaire avec l'histogramme des intensit\u00e9s. Pour obtenir l'histogramme du plomb (\u00e9l\u00e9ment discriminant de la gal\u00e8ne dans notre \u00e9chantillon), on rentre la commande suivante :</p> In\u00a0[5]: Copied! <pre>mc.hist(data,'Pb')\n</pre> mc.hist(data,'Pb') <p>On remarque ainsi que dans l'\u00e9chantillon, il y a une population entre 80% et 100% du pic d'intensit\u00e9, surement correspondant \u00e0 la gal\u00e8ne. Le pic le plus elev\u00e9 d'intensit\u00e9 0 correspond au bruit de fond.</p> <p>Les donn\u00e9es d'entr\u00e9es \u00e9tant des images, les intensit\u00e9s calcul\u00e9es sont ainsi normalis\u00e9es \u00e0 100, o\u00f9 100 correspond au pixel d'intensit\u00e9 maximale de l'\u00e9l\u00e9ment voulu. En connaissant les formules des min\u00e9raux pr\u00e9sents, il est possible de caract\u00e9riser les diff\u00e9rentes populations.</p> <p>La population ayant l'intensit\u00e9 la plus \u00e9lev\u00e9e en plomb correspond \u00e0 de la gal\u00e8ne (PbS).</p> <p>Ainsi dans le tableur d'entr\u00e9e, il est possible de sp\u00e9cifier les valeurs du plomb pour la gal\u00e8ne : ici il est difficile de d\u00e9finir une limite basse, on peut ainsi consid\u00e9rer de garder toutes les valeurs au dessus du bruit de fond : 0.05. Si besoin, on pourra affiner cette valeur plus tard dans le tableau.</p> Element Galene Chalcopyrite Siderite Quartz Al As Ca Cl Cu Fe K Mg Mn Na Pb 0.05 S Si Ti Couleur In\u00a0[6]: Copied! <pre>mineral_cube = mc.mineralcube_creation(data,mask)\n</pre> mineral_cube = mc.mineralcube_creation(data,mask) <p>Pour modifier les valeurs des seuils des masques d\u00e9finis, deux m\u00e9thodes sont possibles :</p> <ul> <li>Modifier le tableur a l'aide de Microsoft Excel ou LibreOffice et le recharger dans python;</li> </ul> In\u00a0[7]: Copied! <pre>mask = mc.load_mask('Data/Mask.xlsx')\n</pre> mask = mc.load_mask('Data/Mask.xlsx') <ul> <li>Modifier directement les valeurs dans pythons</li> </ul> In\u00a0[8]: Copied! <pre>mask.set_value('Galene', 'Pb', '0.05')\n</pre> mask.set_value('Galene', 'Pb', '0.05') <p>Maitenant que des valeurs ont \u00e9t\u00e9 sp\u00e9cifi\u00e9es pour un min\u00e9ral, on peut \u00e9galement cr\u00e9er le cube des masques min\u00e9ralogiques. Il se pr\u00e9sente sous la m\u00eame forme que celui des \u00e9l\u00e9ments, mais ne poss\u00e8de que des 1 la o\u00f9 le pixel est associ\u00e9 au min\u00e9ral, et n'est pas assign\u00e9 si le pixel n'est pas dans le min\u00e9ral</p> <p>De m\u00eame que pour les \u00e9l\u00e9ments, il existe un dictionnaire des min\u00e9raux permettant de retrouver l'index du min\u00e9ral dans le cube cr\u00e9\u00e9</p> In\u00a0[9]: Copied! <pre>mineral_cube.elements\n</pre> mineral_cube.elements Out[9]: <pre>{0: 'Galene', 1: 'Chalcopyrite', 2: 'Siderite', 3: 'Quartz'}</pre> <p>Etant donn\u00e9 que seul deux min\u00e9raux ont \u00e9t\u00e9 d\u00e9finis pour l'instant dans le classeur, seuls deux masques ont r\u00e9\u00e9llement \u00e9t\u00e9 cr\u00e9\u00e9s. On peut visualiser chaque masque avec la commande suivante : <code>mc.hist(mineral_cube,'nom')</code>.</p> <p>Le nom \u00e9tant celui d\u00e9fini dans le tableur par l'utilisateur.</p> <p>Ainsi <code>mc.hist(mineral_cube,'Galene')</code> affiche le masque de la gal\u00e8ne.</p> In\u00a0[10]: Copied! <pre>mc.hist(mineral_cube,'Galene')\n</pre> mc.hist(mineral_cube,'Galene') <p>On peut egalement afficher la carte elementairre et l'histogramme associ\u00e9 d'un \u00e9l\u00e9ment compris dans un masque.</p> In\u00a0[11]: Copied! <pre>mc.hist_in_mask(data, mineral_cube, 'Pb', 'Galene' )\n</pre> mc.hist_in_mask(data, mineral_cube, 'Pb', 'Galene' ) <p>Il est \u00e9galement possible d'afficher la classification min\u00e9ralogique totale sur une seule image :</p> In\u00a0[12]: Copied! <pre>mc.plot_minerals(mineral_cube)\n</pre> mc.plot_minerals(mineral_cube) <p>L'image ainsi obtenue montre le min\u00e9ral classifi\u00e9 ainsi que sa proportion. Sont \u00e9galements affich\u00e9s les pixels class\u00e9s dans plusieurs min\u00e9raux et sont appel\u00e9s mixtes. La somme des proportions des min\u00e9raux et des mixtes boucle \u00e0 100%. La proportion de pixels non index\u00e9s sur toute l'images est \u00e9galement affich\u00e9s. Ici, cela montre que 87.2% des pixels n'ont pas encore \u00e9t\u00e9 class\u00e9s et que sur sur les 12.8% class\u00e9s, 100% correspondent \u00e0 de la gal\u00e8ne.</p> <p>En analysant les diff\u00e9rents histogrammes des \u00e9l\u00e9ments on peut r\u00e9aliser des seuils pour les autres min\u00e9raux et r\u00e9aliser une classification compl\u00e8te. Un exempel de remplissage du tableur est present\u00e9 ci-dessous. Il n'est cependant pas unique et est \u00e0 l'appr\u00e9ciation de l'utilisateur qui connait son echantillon et sa min\u00e9ralogie.</p> Element Galene Chalcopyrite Siderite Quartz Al As Ca 0.2 Cl Cu 0.9 Fe 0.9 0.05 - 0.89 K Mg Mn Na Pb 0.05 S 0.05 0.05 Si 0.7 Ti Couleur Brown Yellow <p>Parmi les mauvaises classifications il est possible de determiner les pourcentages de chaque melange.</p> In\u00a0[13]: Copied! <pre>print(mineral_cube.compute_duplicate_stats())\n</pre> print(mineral_cube.compute_duplicate_stats()) <pre>        0             1         2       3  Percentage of Mixed\n0  Galene             0  Siderite       0            89.314158\n1  Galene  Chalcopyrite         0       0             4.033690\n2       0             0  Siderite  Quartz             3.764396\n3  Galene             0         0  Quartz             2.887756\n</pre> <p>On remarque que la plupart des mixtes sont entre la galene et la siderite car nous ne sommes pas assez restrictif sur les teneurs pour chaque phases.</p> In\u00a0[14]: Copied! <pre>mask.table.describe()\n</pre> mask.table.describe() Out[14]: Chalcopyrite count 3.000000 mean 0.616667 std 0.490748 min 0.050000 25% 0.475000 50% 0.900000 75% 0.900000 max 0.900000"},{"location":"examples/Tutorial_fr.html#classification-de-phases-et-extraction-de-masques-associes","title":"Classification de phases et extraction de masques associ\u00e9s\u00b6","text":""},{"location":"examples/Tutorial_fr.html#prerequis","title":"Pr\u00e9requis\u00b6","text":""},{"location":"examples/Tutorial_fr.html#fichiers-necessaires","title":"Fichiers n\u00e9cessaires :\u00b6","text":"<ul> <li>Les donn\u00e9es \u00e9l\u00e9mentaires.</li> </ul> <p>Il peut s'agir de cartes \u00e9l\u00e9mentaires (.bmp ou .tif), mais aussi des cartes des donn\u00e9es brutes (.txt) ou encore du cube complet (.raw et du fichier annexe .rpl)</p>"},{"location":"examples/Tutorial_fr.html#les-informations-a-rentrer-dans-chaque-cellule-correspondent-soit","title":"Les informations \u00e0 rentrer dans chaque cellule correspondent soit :\u00b6","text":"<ul> <li>\u00e0 une valeur comprise entre 0 et 1 si la carte utilis\u00e9e est un fichier .bmp ou .tif.</li> <li>\u00e0 une valeur correspondant \u00e0 un nombre de coups si la carte utilis\u00e9e est un fichier .txt ou .raw (et .rpl associ\u00e9e) et que l'utilisateur souhaite travailler avec les valeurs en nombres de coups. Il peut cependant aussi travailler avec des valeurs comprises entre 0 et 1.</li> </ul>"},{"location":"examples/Tutorial_fr.html#quelles-types-de-valeurs-entrer","title":"Quelles types de valeurs entrer\u00b6","text":"<ul> <li>Il peut s'agir d'un seul nombre. Si c'est un nombre \u00e0 virgule, la s\u00e9paration se fait par un point.</li> <li>Il peut s'agir d'une plage de valeurs ou les deux nombres sont s\u00e9par\u00e9s par un tiret (dash).</li> </ul>"},{"location":"examples/Tutorial_fr.html#comment-utiliser-le-programme","title":"Comment utiliser le programme\u00b6","text":""},{"location":"examples/Tutorial_fr.html#import-de-la-librairie-marcia","title":"Import de la librairie marcia\u00b6","text":""},{"location":"examples/Tutorial_fr.html#chargement-des-donnees-elementaires","title":"Chargement des donn\u00e9es \u00e9l\u00e9mentaires\u00b6","text":""},{"location":"examples/Tutorial_fr.html#chargement-du-fichier-de-parametrage-de-la-classification-par-phases","title":"Chargement du fichier de parametrage de la classification par phases\u00b6","text":""},{"location":"examples/Tutorial_fr.html#affichage-des-zones-de-concentrations","title":"Affichage des zones de concentrations\u00b6","text":""},{"location":"examples/Tutorial_fr.html#creation-du-cube-de-phases","title":"Cr\u00e9ation du cube de phases\u00b6","text":""},{"location":"examples/Tutorial_fr.html#modification-des-parametres-de-classification-de-phases","title":"Modification des param\u00e8tres de classification de phases\u00b6","text":""},{"location":"examples/Tutorial_fr.html#histogramme-dans-une-phase-specifique","title":"Histogramme dans une phase sp\u00e9cifique\u00b6","text":""},{"location":"examples/Tutorial_fr.html#classification-totale-des-phases-et-pourcentages-associes","title":"Classification totale des phases et pourcentages associ\u00e9s\u00b6","text":""},{"location":"examples/Tutorial_fr.html#determiner-les-phases-couplees-dans-les-mixtes","title":"D\u00e9terminer les phases coupl\u00e9es dans les mixtes\u00b6","text":""},{"location":"examples/quick-start.html","title":"Quick Start","text":"In\u00a0[1]: Copied! <pre>import marcia as mc\n</pre> import marcia as mc In\u00a0[2]: Copied! <pre>data = mc.load('Data/lead_ore','.bmp', True)\n</pre> data = mc.load('Data/lead_ore','.bmp', True) In\u00a0[3]: Copied! <pre>mc.hist(data, 'Pb')\n</pre> mc.hist(data, 'Pb') In\u00a0[4]: Copied! <pre>mask = mc.load_mask('Data/Mask.xlsx')\n</pre> mask = mc.load_mask('Data/Mask.xlsx') In\u00a0[5]: Copied! <pre>mineral_cube = mc.mineralcube_creation(data,mask)\n</pre> mineral_cube = mc.mineralcube_creation(data,mask) In\u00a0[6]: Copied! <pre>mc.plot_minerals(mineral_cube)\n</pre> mc.plot_minerals(mineral_cube) In\u00a0[7]: Copied! <pre>mc.hist(mineral_cube, 'Galene')\n</pre> mc.hist(mineral_cube, 'Galene') <p>Masks can be save as raw tiff images.</p> In\u00a0[8]: Copied! <pre>mc.save(mineral_cube, 'Galene', raw=True)\n</pre> mc.save(mineral_cube, 'Galene', raw=True)"},{"location":"examples/quick-start.html#import-required-libraries","title":"Import Required Libraries\u00b6","text":""},{"location":"examples/quick-start.html#load-data","title":"Load Data\u00b6","text":""},{"location":"examples/quick-start.html#load-classification-table","title":"Load Classification Table\u00b6","text":""},{"location":"examples/quick-start.html#see-classification","title":"See classification\u00b6","text":""},{"location":"examples/quick-start.html#check-classification-accuracy","title":"Check classification accuracy\u00b6","text":""},{"location":"examples/quick-start.html#export-mask-to-image","title":"Export mask to image\u00b6","text":""}]}