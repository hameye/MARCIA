{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"index.html#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"index.html#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"index.html#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"examples.html","text":"Workflow Classes Mask Class that allows to do a mineralogical classification of a sample provided the elemental data and a spreadsheet containing the elemental information needed for each mineral. The classification indicates the minerals, the percentage of each, the percentage of pixels that are classified more than once. It also indicates the percentage of the number of pixel that are not indexed. It also enables to extract a binaray image per mineral in order to use it as a mask onto the datacube (.rpl file) to facilitate quantitative analysis by the software. The spreadsheet can contain elemental and ratios querries and also a line for the color querries. Attributes: Name Type Description prefix Common name to all data files (eg: lead_ore_). suffix Type of the data file. table Name of spreadsheet containing thresholds (eg: Mask.xlsx). normalization Indicate if data are normalized or not, only valid test str test Methods create_mineral_mask ( self ) Create a 2D array that associate each pixel to a mask by assigning a value to each pixel. It also creates a dictionnary containing the relative proportion of a value compared to others. Source code in marcia/mask.py def create_mineral_mask ( self ): \"\"\" Create a 2D array that associate each pixel to a mask by assigning a value to each pixel. It also creates a dictionnary containing the relative proportion of a value compared to others. \"\"\" # Creation of proportion dictionnary proportion = {} # Initialization of 2D array array = np . zeros (( self . data_cube . shape [ 0 ], self . data_cube . shape [ 1 ])) # Convert the array to nan values array [ np . isfinite ( array )] = np . nan # Loop over the mask to check pixels that are assigned more than once for indice in range ( len ( self . Minerals )): array [( np . isfinite ( self . mineral_cube [:, :, indice ])) & ( np . nansum ( self . mineral_cube , axis = 2 ) == 1 )] = indice array [ np . where ( np . nansum ( self . mineral_cube , axis = 2 ) > 1 ) ] = len ( self . Minerals ) + 1 for indice in range ( len ( self . Minerals )): proportion [ indice ] = np . where ( array == indice )[ 0 ] . shape [ 0 ] / np . sum ( np . isfinite ( array )) * 100 return array cube_masking_keep ( self , mineral ) Recreates a raw datacube containing data only in the wanted mask. Parameters: Name Type Description Default mineral str Name of the wanted mask (eg: 'Galene'). required Source code in marcia/mask.py def cube_masking_keep ( self , mineral : str ): \"\"\" Recreates a raw datacube containing data only in the wanted mask. Args: mineral: Name of the wanted mask (eg: 'Galene'). \"\"\" # Conversion of given string indices to integer indice of the cube mineral = list ( self . Minerals . values ()) . index ( str ( mineral )) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isnan ( self . mineral_cube [:, :, mineral ])] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_kept_' + self . Minerals [ mineral ] + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_kept_' + self . Minerals [ mineral ] + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close () cube_masking_remove ( self , mineral ) Recreates a raw datacube containing all the data without the mask not wanted. Parameters: Name Type Description Default mineral str Name of the wanted mask (eg: 'Galene') required Source code in marcia/mask.py def cube_masking_remove ( self , mineral : str ): \"\"\" Recreates a raw datacube containing all the data without the mask not wanted. Args: mineral : Name of the wanted mask (eg: 'Galene') \"\"\" # Conversion of given string indices to integer indice of the cube if mineral == 'mixed' : a = self . create_mineral_mask ()[ 0 ] mixed = np . where ( a < np . nanmax ( a ), np . nan , a ) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isfinite ( mixed )] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_removed_mixed' + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_removed_mixed' + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close () elif mineral == 'not indexed' : a = self . create_mineral_mask ()[ 0 ] nan = np . where ( np . isnan ( a ), 0 , a ) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isfinite ( nan )] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_removed_nan' + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_removed_nan' + + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close () else : mineral = list ( self . Minerals . values ()) . index ( str ( mineral )) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isfinite ( self . mineral_cube [:, :, mineral ])] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_removed_' + self . Minerals [ mineral ] + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_removed_' + self . Minerals [ mineral ] + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close () datacube_creation ( self ) Create a 3D array (X and Y are the dimensions of the sample and Z dimension is the number of elements/emission lines taken into account for the classification) It stacks the information contained in the elemental files given ranked according to the spreasheet ranking. If the normalization is asked or if the elemental map is an image, the data in the array are between 0 and 100. If there is a scalebar, the corresponding pixels are non assigned. Three types of elemental files are accepted Imges (.bmp of .tif), which are RGB files : each pixel contains 3 values between 0 and 255. The rgb is put into greyscale calculated by the norm 2. Textfile (.txt), which is already the elemental array where the values are the number of counts. Raw file (.rpl), wich is the datacube containing all the spectra for every pixel. The hyperspy library is used to extract the emission lines corresponding to the wanted elements. Textfiles and raw files can be normalized or not, the spreadsheet must be written according to that. The function also creates a dictionnary containing the Z position of the element in the 3D array created. 2 class files created in that function. Source code in marcia/mask.py def datacube_creation ( self ): \"\"\" Create a 3D array (X and Y are the dimensions of the sample and Z dimension is the number of elements/emission lines taken into account for the classification) It stacks the information contained in the elemental files given ranked according to the spreasheet ranking. If the normalization is asked or if the elemental map is an image, the data in the array are between 0 and 100. If there is a scalebar, the corresponding pixels are non assigned. Three types of elemental files are accepted ------------------------------------------- - Imges (.bmp of .tif), which are RGB files : each pixel contains 3 values between 0 and 255. The rgb is put into greyscale calculated by the norm 2. - Textfile (.txt), which is already the elemental array where the values are the number of counts. - Raw file (.rpl), wich is the datacube containing all the spectra for every pixel. The hyperspy library is used to extract the emission lines corresponding to the wanted elements. Textfiles and raw files can be normalized or not, the spreadsheet must be written according to that. The function also creates a dictionnary containing the Z position of the element in the 3D array created. 2 class files created in that function. \"\"\" # Check if the data files are images if self . suffix in ( '.bmp' , '.tif' , '.jpg' , '.png' ): # Set automatic normalization to True self . normalization = True # Creation of element names dictionnary self . Elements = {} # Read the first image to know the dimensions test_image = np . linalg . norm ( imread ( self . prefix + self . table . iloc [ 0 ][ 0 ] + self . suffix ), axis = 2 ) self . data_cube = np . zeros ( ( test_image . shape [ 0 ], test_image . shape [ 1 ], self . table . shape [ 0 ])) test_image [:, :] = 0 # Loop over elements in the table for element in range ( self . table . shape [ 0 ]): self . Elements [ element ] = self . table . iloc [ element ][ 'Element' ] # Check if the element is not a ratio of two elements if '/' not in self . table . iloc [ element ][ 'Element' ]: # Load of the RGB image and normalization to one component self . data_cube [:, :, element ] = np . linalg . norm ( imread ( self . prefix + self . table . iloc [ element ][ 0 ] + self . suffix ), axis = 2 ) # If the element is actually a ratio of two elements else : # Load of the two images image_over = imread ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 0 ] + self . suffix ) image_under = imread ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 1 ] + self . suffix ) # Normalization of the two images image_over_grey = np . linalg . norm ( image_over , axis = 2 ) image_under_grey = np . linalg . norm ( image_under , axis = 2 ) # Set 0 values to 0.01 in denominator image in order to # avoid division by 0 image_under_grey [ image_under_grey == 0. ] = 0.01 self . data_cube [ :, :, element ] = image_over_grey / image_under_grey # Normalization over 100 to every element of the cube for i in range ( len ( self . Elements )): self . data_cube [:, :, i ] = self . data_cube [ :, :, i ] / np . nanmax ( self . data_cube [:, :, i ]) * 100 # Check if data are textfiles consisting of raw count data per pixel # per energy elif self . suffix == '.txt' : self . Elements = {} # Read the first image to know the dimensions test_image = np . loadtxt ( self . prefix + self . table . iloc [ 0 ][ 0 ] + self . suffix , delimiter = ';' ) self . data_cube = np . zeros ( ( test_image . shape [ 0 ], test_image . shape [ 1 ], self . table . shape [ 0 ])) test_image [:, :] = 0 # Loop over elements in the table for element in range ( self . table . shape [ 0 ]): self . Elements [ element ] = self . table . iloc [ element ][ 'Element' ] # Check if the element is not a ratio of two elements if '/' not in self . table . iloc [ element ][ 'Element' ]: # Load of the data count per element self . data_cube [:, :, element ] = np . loadtxt ( self . prefix + self . table . iloc [ element ][ 0 ] + self . suffix , delimiter = ';' ) # If the element is actually a ratio of two elements else : image_over_grey = np . loadtxt ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 0 ] + self . suffix , delimiter = ';' ) image_under_grey = np . loadtxt ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 1 ] + self . suffix , delimiter = ';' ) self . data_cube [ :, :, element ] = image_over_grey / image_under_grey # If user wants to see normalized over 100 data # This option makes impossible intensity comparison over element if self . normalization : for i in range ( len ( self . Elements )): self . data_cube [:, :, i ] = self . data_cube [ :, :, i ] / np . nanmax ( self . data_cube [:, :, i ]) * 100 # Check if data are .rpl file, that is complete datacube # Load of the file using HyperSpy library elif self . suffix == '.rpl' : cube = hs . load ( self . prefix + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) cube . axes_manager [ - 1 ] . name = 'E' cube . axes_manager [ 'E' ] . units = 'keV' cube . axes_manager [ 'E' ] . scale = 0.01 cube . axes_manager [ 'E' ] . offset = - 0.97 self . Elements = {} self . data_cube = np . zeros (( cube . axes_manager . shape [ 1 ], cube . axes_manager . shape [ 0 ], self . table . shape [ 0 ])) for element in range ( self . table . shape [ 0 ]): self . Elements [ element ] = self . table . iloc [ element ][ 'Element' ] if '/' not in self . table . iloc [ element ][ 'Element' ]: cube . set_elements ([ self . table . iloc [ element ][ 'Element' ]]) array = cube . get_lines_intensity () self . data_cube [:, :, element ] = np . asarray ( array [ 0 ]) else : cube . set_elements ( [ self . table [ 'Element' ][ element ] . split ( '/' )[ 0 ]]) array = cube . get_lines_intensity () image_over = np . asarray ( array [ 0 ]) cube . set_elements ( [ self . table [ 'Element' ][ element ] . split ( '/' )[ 1 ]]) array = cube . get_lines_intensity () image_under = np . asarray ( array [ 0 ]) image_under [ image_under == 0. ] = 0.001 self . data_cube [ :, :, element ] = image_over / image_under if self . normalization : for i in range ( len ( self . Elements )): self . data_cube [:, :, i ] = self . data_cube [ :, :, i ] / np . nanmax ( self . data_cube [:, :, i ]) * 100 # Raise Exception to provide valide data type else : raise Exception ( f \" { self . prefix } invalid data type. \" f \"Valid data types are: \" f \".png, .bmp, .tif, .txt or .rpl \" ) get_biplot ( self , indicex , indicey ) Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Parameters: Name Type Description Default indicex str Name of the wanted element on x axis (eg: 'Fe'). required indicey str Name of the wanted element on y axis (eg: 'Pb'). required Source code in marcia/mask.py def get_biplot ( self , indicex : str , indicey : str ): \"\"\" Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Args: indicex: Name of the wanted element on x axis (eg: 'Fe'). indicey: Name of the wanted element on y axis (eg: 'Pb'). \"\"\" # Conversion of given string indices to integer indices of the cubes indicex = list ( self . Elements . values ()) . index ( str ( indicex )) indicey = list ( self . Elements . values ()) . index ( str ( indicey )) fig , axes = plt . subplots () # Number of points limited to 100,000 for computationnal time Valuesx = self . data_cube [ :, :, indicex ][ np . isfinite ( self . data_cube [:, :, indicex ])] Valuesy = self . data_cube [ :, :, indicey ][ np . isfinite ( self . data_cube [:, :, indicey ])] data = { 'x' : Valuesx , 'y' : Valuesy } df = pd . DataFrame ( data ) # Limit number of samples to 100,000 if len ( df ) > 100000 : print ( 'Number of points limited to 100000' ) df = df . sample ( n = 100000 ) df = df . reset_index () . drop ( columns = [ 'index' ]) plt . xlim ( 0 , np . max ( Valuesx )) plt . ylim ( 0 , np . max ( Valuesy )) plt . xlabel ( str ( self . Elements [ indicex ])) plt . ylabel ( str ( self . Elements [ indicey ])) sns . scatterplot ( x = df . x , y = df . y , alpha = 0.3 , marker = \"+\" ) fig . tight_layout () plt . show () get_hist ( self , indice ) Plot the elemental map on the left side an the corresponding hitogram of intensity on the right side Input is the index of the element in the 3D array Useful function in order to set the threshold in the spreadsheet. Parameters: Name Type Description Default indice str Name of the wanted element (eg: 'Fe') required Source code in marcia/mask.py def get_hist ( self , indice : str ): \"\"\" Plot the elemental map on the left side an the corresponding hitogram of intensity on the right side Input is the index of the element in the 3D array Useful function in order to set the threshold in the spreadsheet. Args: indice: Name of the wanted element (eg: 'Fe') \"\"\" # Conversion of given string indices to integer indice of the cube indice = list ( self . Elements . values ()) . index ( str ( indice )) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 5 )) ax = axes . ravel () # Keep only finite values finite_data = self . data_cube [:, :, indice ][ np . isfinite ( self . data_cube [:, :, indice ])] im = ax [ 0 ] . imshow ( self . data_cube [:, :, indice ]) ax [ 0 ] . grid () ax [ 0 ] . set_title ( \"Carte \u00e9l\u00e9mentaire : \" + self . Elements [ indice ]) fig . colorbar ( im , ax = ax [ 0 ]) plt . ylim ( 0 , np . max ( finite_data )) sns . distplot ( finite_data , kde = False , ax = axes [ 1 ], hist_kws = { 'range' : ( 0.0 , np . max ( finite_data ))}, vertical = True ) # Logarithm scale because background has a lof ot points and flatten # interesting information if linear ax [ 1 ] . set_xscale ( 'log' ) ax [ 1 ] . set_title ( \"Histograme d'intensit\u00e9 : \" + self . Elements [ indice ]) fig . tight_layout () plt . show () get_mask ( self , indice ) Plot the mineral mask wanted Input is the index of the mineral in the 3D array (cube). Parameters: Name Type Description Default indice str Name of the wanted mask (eg: 'Galene'). required Source code in marcia/mask.py def get_mask ( self , indice : str ): \"\"\" Plot the mineral mask wanted Input is the index of the mineral in the 3D array (cube). Args: indice: Name of the wanted mask (eg: 'Galene'). \"\"\" # Conversion of given string indices to integer indice of the cube indice = list ( self . Minerals . values ()) . index ( str ( indice )) fig = plt . figure () plt . imshow ( self . mineral_cube [:, :, indice ]) plt . title ( self . Minerals [ indice ]) plt . grid () plt . show () get_masked_element ( self , element , mineral ) Plot the elemental map and the histogram associated only in a specific mask. Parameters: Name Type Description Default element str Name of the wanted element (eg: 'Fe'). required mineral str Name of the wanted mask (eg: 'Galene'). required Source code in marcia/mask.py def get_masked_element ( self , element : str , mineral : str ): \"\"\" Plot the elemental map and the histogram associated only in a specific mask. Args: element: Name of the wanted element (eg: 'Fe'). mineral: Name of the wanted mask (eg: 'Galene'). \"\"\" # Conversion of given string indices to integer indices of the cubes element = list ( self . Elements . values ()) . index ( str ( element )) mineral = list ( self . Minerals . values ()) . index ( str ( mineral )) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 5 )) ax = axes . ravel () Anan = self . data_cube [:, :, element ][ np . isfinite ( self . data_cube [:, :, element ])] array = self . data_cube [:, :, element ] array [ np . isnan ( self . mineral_cube [:, :, mineral ])] = 0 im = ax [ 0 ] . imshow ( array ) ax [ 0 ] . grid () ax [ 0 ] . set_title ( \"Carte \u00e9l\u00e9mentaire de {} masqu\u00e9\u00e9 par {} \" . format ( self . Elements [ element ], self . Minerals [ mineral ])) fig . colorbar ( im , ax = ax [ 0 ]) plt . ylim ( 0 , np . max ( Anan )) sns . distplot ( Anan , kde = False , ax = axes [ 1 ], hist_kws = { 'range' : ( 0.0 , np . max ( Anan ))}, vertical = True ) ax [ 1 ] . set_xscale ( 'log' ) ax [ 1 ] . set_title ( \"Histograme d'intensit\u00e9 : \" + self . Elements [ element ]) fig . tight_layout () plt . show () get_triplot ( self , indicex , indicey , indicez ) Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Parameters: Name Type Description Default indicex str Name of the wanted element on x axis(eg: 'Fe'). required indicey str Name of the wanted element on y axis (eg: 'Pb'). required indicez str Name of the wanted element on colorscale (eg: 'Cu'). required Source code in marcia/mask.py def get_triplot ( self , indicex : str , indicey : str , indicez : str ): \"\"\" Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Args: indicex: Name of the wanted element on x axis(eg: 'Fe'). indicey: Name of the wanted element on y axis (eg: 'Pb'). indicez: Name of the wanted element on colorscale (eg: 'Cu'). \"\"\" # Conversion of given string indices to integer indices of the cubes indicex = list ( self . Elements . values ()) . index ( str ( indicex )) indicey = list ( self . Elements . values ()) . index ( str ( indicey )) indicez = list ( self . Elements . values ()) . index ( str ( indicez )) fig , axes = plt . subplots () Valuesx = self . data_cube [ :, :, indicex ][ np . isfinite ( self . data_cube [:, :, indicex ])] Valuesy = self . data_cube [ :, :, indicey ][ np . isfinite ( self . data_cube [:, :, indicey ])] Valuesz = self . data_cube [ :, :, indicez ][ np . isfinite ( self . data_cube [:, :, indicez ])] data = { 'x' : Valuesx , 'y' : Valuesy , 'z' : Valuesz } df = pd . DataFrame ( data ) if len ( df ) > 100000 : print ( 'Number of points limited to 100000' ) df = df . sample ( n = 100000 ) df = df . reset_index () . drop ( columns = [ 'index' ]) plt . xlim ( 0 , np . max ( Valuesx )) plt . ylim ( 0 , np . max ( Valuesy )) plt . title ( str ( self . Elements [ indicez ])) sns . scatterplot ( x = df . x , y = df . y , hue = df . z , alpha = 0.3 , marker = \"+\" ) plt . xlabel ( str ( self . Elements [ indicex ])) plt . ylabel ( str ( self . Elements [ indicey ])) fig . tight_layout () plt . show () load_table ( self ) Load the spreadsheet into the programm. Verification if information of colors are required for the classification. Colors are also specified in the spreadsheet. Source code in marcia/mask.py def load_table ( self ): \"\"\" Load the spreadsheet into the programm. Verification if information of colors are required for the classification. Colors are also specified in the spreadsheet. \"\"\" # Check if table is csv/txt or xlsx if self . table_name . split ( '.' )[ - 1 ] in ( 'csv' , 'txt' ): self . table = pd . read_csv ( self . table_name ) elif 'xls' in self . table_name . split ( '.' )[ - 1 ]: self . table = pd . read_excel ( self . table_name ) else : raise Exception ( f \" { self . table_name . split ( '.' )[ - 1 ] } \" f \"invalid Table format.\" f \"Valid data types are: .csv, .txt, or .xls \" ) # Check if table has specific colors for the masks if self . table [ 'Element' ] . str . contains ( 'ouleur|olor' ) . any (): indice = np . where ( self . table [ 'Element' ] . str . contains ( 'ouleur|olor' ))[ 0 ][ 0 ] # Creation of dictionnary containing the colors self . colors = {} for coul in range ( 1 , self . table . iloc [ indice ] . shape [ 0 ]): if isinstance ( self . table . iloc [ indice ][ coul ], str ): self . colors [ coul - 1 ] = self . table . iloc [ indice ][ coul ] # For simplicity in the process, color column is then removed self . table = self . table . drop ([ indice ]) mineralcube_creation ( self ) Create a 3D numpy array (X and Y are the dimensions of the sample and Z dimension is the number of minerals wanted for the classification). The minerals are defined by the columns in the spreadsheet. The 2D array create per mineral depends on the threshold specified in the spreadsheet. If one value is given, it corresponds to the minimum threshold to be in the mineral. If two values separated by a dash, it corresponds to the range of values for this element to be in the mineral. Given values are outside the range. Each mineral array is binary with 1 where the pixel is in the mineral and NaN (non assigned) where the pixel is not in the mineral. The function also creates a dictionnary containing the Z position of the minerals in the 3D array created. 2 class files created in that function. Source code in marcia/mask.py def mineralcube_creation ( self ): \"\"\" Create a 3D numpy array (X and Y are the dimensions of the sample and Z dimension is the number of minerals wanted for the classification). The minerals are defined by the columns in the spreadsheet. The 2D array create per mineral depends on the threshold specified in the spreadsheet. If one value is given, it corresponds to the minimum threshold to be in the mineral. If two values separated by a dash, it corresponds to the range of values for this element to be in the mineral. Given values are outside the range. Each mineral array is binary with 1 where the pixel is in the mineral and NaN (non assigned) where the pixel is not in the mineral. The function also creates a dictionnary containing the Z position of the minerals in the 3D array created. 2 class files created in that function. \"\"\" # Creation of mineral/mask names dictionnary self . Minerals = {} # Intializing data cube self . mineral_cube = np . zeros (( self . data_cube . shape [ 0 ], self . data_cube . shape [ 1 ], self . table . shape [ 1 ] - 1 )) # Loop over each mask in order to fill the cube and dictionnary for mask in range ( 1 , self . table . shape [ 1 ]): # Extract name of the mask name = self . table . columns [ mask ] # Fill the dictionnary, the key being an integer index self . Minerals [ mask - 1 ] = name # Values are convert to string in order to facilitate later split str_table = self . table [ name ] . astype ( 'str' , copy = True ) # Keeping indices of elements that are used in a mask index_str = np . where ( self . table [ name ] . notnull ())[ 0 ] # Initializing intermediate 3D array mask_i_str = np . zeros (( self . data_cube . shape [ 0 ], self . data_cube . shape [ 1 ], index_str . shape [ 0 ])) # Loop over elements of the mask for k in range ( index_str . shape [ 0 ]): mask_i_str [:, :, k ] = self . data_cube [:, :, index_str [ k ]] # If only one value in the table: it corresponds to minimum # threshold if len ( str_table [ index_str [ k ]] . split ( '-' )) == 1 : threshold_min = float ( str_table [ index_str [ k ]] . split ( '-' )[ 0 ]) threshold_max = None # If more thant one value (should be 2): it corresponds to the # range of accepted values else : threshold_min = float ( str_table [ index_str [ k ]] . split ( '-' )[ 0 ]) threshold_max = float ( str_table [ index_str [ k ]] . split ( '-' )[ 1 ]) # If the value are normalized, the threshold is between 0 and # 1: need to compare to maximum value if self . normalization : mask_i_str [:, :, k ][ mask_i_str [ :, :, k ] < threshold_min * np . nanmax ( mask_i_str [:, :, k ])] = np . nan if threshold_max : mask_i_str [:, :, k ][ mask_i_str [ :, :, k ] > threshold_max * np . nanmax ( mask_i_str [:, :, k ])] = np . nan # Values outside thresholds are nan, and valid values are # set to 1 mask_i_str [ np . isfinite ( mask_i_str )] = 1 # If not normalize, threshold is just the number of counts else : mask_i_str [:, :, k ][ mask_i_str [:, :, k ] < threshold_min ] = np . nan if threshold_max : mask_i_str [:, :, k ][ mask_i_str [:, :, k ] > threshold_max ] = np . nan # Values outside thresholds are nan, and valid values are # set to 1 mask_i_str [ np . isfinite ( mask_i_str )] = 1 # 3D array is stacked mask_i_str = np . nansum ( mask_i_str , axis = 2 ) # Mask correspond to maximum values: ones that satisfied all # conditions mask_i_str [ mask_i_str < np . max ( mask_i_str )] = np . nan # Mask cube 2D slice is filled with 1 where mask is true self . mineral_cube [:, :, mask - 1 ] = mask_i_str / \\ np . nanmax ( mask_i_str ) plot_mineral_mask ( self ) For mineralogy purposes, valid only if all masks are minerals Plot all the mask onto one picture in order to visualize the classification. Each pixel correspond to only one mineral at the time, if not, it is classified as \"mixed\". Source code in marcia/mask.py def plot_mineral_mask ( self ): \"\"\" For mineralogy purposes, valid only if all masks are minerals Plot all the mask onto one picture in order to visualize the classification. Each pixel correspond to only one mineral at the time, if not, it is classified as \"mixed\". \"\"\" fig = plt . figure () array , proportion = self . _create_mineral_mask_and_prop () # First plot to generate random colors im = plt . imshow ( array , cmap = 'Paired' ) # Store finite values for later purpose finite_values_array = array [ np . isfinite ( array )] # Check if mixed pixels, need to add one more value if np . nansum ( self . mineral_cube , axis = 2 ) . max () > 1 : values = np . arange ( len ( self . Minerals ) + 1 ) else : values = np . arange ( len ( self . Minerals )) colors = [ im . cmap ( im . norm ( value )) for value in values ] plt . close () # Test if colors where specify in the table if self . colors : # If true, specified values are replaced for value in self . colors : colors [ value ] = self . colors [ value ] # Generating the new colormap new_colormap = ListedColormap ( colors ) # Open new figure fig = plt . figure () im = plt . imshow ( array , cmap = new_colormap , vmin = values . min (), vmax = values . max ()) # create a patch for every color # If true, there are mixed pixels: need to add a patch of mixte if np . nanmax ( array ) > len ( self . Minerals ): patches = [ mpatches . Patch ( color = colors [ np . where ( values == int ( i ))[ 0 ][ 0 ]], label = \" {} : {} %\" . format ( self . Minerals [ int ( i )], str ( round ( proportion [ int ( i )], 2 )))) for i in values [ : - 1 ] if round ( proportion [ int ( i )], 2 ) > 0 ] patches . append ( mpatches . Patch ( color = colors [ - 1 ], label = \" {} : {} %\" . format ( 'Misclassified' , str ( round ( np . where ( array == np . nanmax ( array ))[ 0 ] . shape [ 0 ] / np . sum ( np . isfinite ( array )) * 100 , 2 ))))) # If False, just add patches of corresponding masks else : patches = [ mpatches . Patch ( color = colors [ np . where ( values == int ( i ))[ 0 ][ 0 ]], label = \" {} : {} %\" . format ( self . Minerals [ int ( i )], str ( round ( proportion [ int ( i )], 2 )))) for i in values [:] if round ( proportion [ int ( i )], 2 ) > 0 ] # Finally add a patch to specify proporty of non-classified pixel # Two reasons : images is bigger than sample or misclassification patches . append ( mpatches . Patch ( color = 'white' , label = \" {} : {} %\" . format ( 'Not classified' , str ( round ( ( self . data_cube . shape [ 0 ] * self . data_cube . shape [ 1 ] - len ( finite_values_array )) / ( self . data_cube . shape [ 0 ] * self . data_cube . shape [ 1 ]) * 100 , 2 ))))) # Add patches to the legend plt . legend ( handles = patches , bbox_to_anchor = ( 1.05 , 1 ), loc = 2 , borderaxespad = 0. ) plt . grid ( True ) plt . title ( \"Mineralogical classification - \" + self . prefix [: - 1 ]) plt . tight_layout () plt . show () save_mask ( self , indice , raw = False ) Save the mineral mask wanted as a .tif file. Input is the index of the mineral in the 3D array (cube). Parameters: Name Type Description Default indice str Name of the wanted element (eg: 'Fe') required Source code in marcia/mask.py def save_mask ( self , indice : str , raw : bool = False ): \"\"\" Save the mineral mask wanted as a .tif file. Input is the index of the mineral in the 3D array (cube). Args: indice: Name of the wanted element (eg: 'Fe') \"\"\" indice = list ( self . Minerals . values ()) . index ( str ( indice )) if not raw : # Conversion of given string indices to integer indice of the cube plt . imshow ( self . mineral_cube [:, :, indice ]) plt . title ( self . Minerals [ indice ]) plt . savefig ( 'Mask_' + self . Minerals [ indice ] + '.tif' ) plt . close () else : test_array = ( self . mineral_cube [ :, :, indice ] * 255 ) . astype ( np . uint8 ) image = Image . fromarray ( test_array ) image . save ( 'Mask_' + self . Minerals [ indice ] + '.tif' ) save_mask_spectrum ( self , mask ) Save the mean spectrum of a given mask as a txt file First column is channel Second column is counts Parameters: Name Type Description Default mask str Name of the wanted mask (eg: 'Galene') required Source code in marcia/mask.py def save_mask_spectrum ( self , mask : str ): \"\"\"Save the mean spectrum of a given mask as a txt file First column is channel Second column is counts Args: mask: Name of the wanted mask (eg: 'Galene') \"\"\" mineral = list ( self . Minerals . values ()) . index ( str ( mask )) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isnan ( self . mineral_cube [:, :, mineral ])] = 0 cube = hs . signals . Signal1D ( array ) spectrum = cube . sum () . data d = { 'Counts' : spectrum } dataframe = pd . DataFrame ( data = d ) dataframe . index . name = 'channel' dataframe . to_csv ( mask + '_mean_spectrum.txt' )","title":"API Reference"},{"location":"examples.html#workflow","text":"","title":"Workflow"},{"location":"examples.html#marcia.mask-classes","text":"","title":"Classes"},{"location":"examples.html#marcia.mask.Mask","text":"Class that allows to do a mineralogical classification of a sample provided the elemental data and a spreadsheet containing the elemental information needed for each mineral. The classification indicates the minerals, the percentage of each, the percentage of pixels that are classified more than once. It also indicates the percentage of the number of pixel that are not indexed. It also enables to extract a binaray image per mineral in order to use it as a mask onto the datacube (.rpl file) to facilitate quantitative analysis by the software. The spreadsheet can contain elemental and ratios querries and also a line for the color querries. Attributes: Name Type Description prefix Common name to all data files (eg: lead_ore_). suffix Type of the data file. table Name of spreadsheet containing thresholds (eg: Mask.xlsx). normalization Indicate if data are normalized or not, only valid test str test","title":"Mask"},{"location":"examples.html#marcia.mask.Mask-methods","text":"","title":"Methods"},{"location":"examples.html#marcia.mask.Mask.create_mineral_mask","text":"Create a 2D array that associate each pixel to a mask by assigning a value to each pixel. It also creates a dictionnary containing the relative proportion of a value compared to others. Source code in marcia/mask.py def create_mineral_mask ( self ): \"\"\" Create a 2D array that associate each pixel to a mask by assigning a value to each pixel. It also creates a dictionnary containing the relative proportion of a value compared to others. \"\"\" # Creation of proportion dictionnary proportion = {} # Initialization of 2D array array = np . zeros (( self . data_cube . shape [ 0 ], self . data_cube . shape [ 1 ])) # Convert the array to nan values array [ np . isfinite ( array )] = np . nan # Loop over the mask to check pixels that are assigned more than once for indice in range ( len ( self . Minerals )): array [( np . isfinite ( self . mineral_cube [:, :, indice ])) & ( np . nansum ( self . mineral_cube , axis = 2 ) == 1 )] = indice array [ np . where ( np . nansum ( self . mineral_cube , axis = 2 ) > 1 ) ] = len ( self . Minerals ) + 1 for indice in range ( len ( self . Minerals )): proportion [ indice ] = np . where ( array == indice )[ 0 ] . shape [ 0 ] / np . sum ( np . isfinite ( array )) * 100 return array","title":"create_mineral_mask()"},{"location":"examples.html#marcia.mask.Mask.cube_masking_keep","text":"Recreates a raw datacube containing data only in the wanted mask. Parameters: Name Type Description Default mineral str Name of the wanted mask (eg: 'Galene'). required Source code in marcia/mask.py def cube_masking_keep ( self , mineral : str ): \"\"\" Recreates a raw datacube containing data only in the wanted mask. Args: mineral: Name of the wanted mask (eg: 'Galene'). \"\"\" # Conversion of given string indices to integer indice of the cube mineral = list ( self . Minerals . values ()) . index ( str ( mineral )) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isnan ( self . mineral_cube [:, :, mineral ])] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_kept_' + self . Minerals [ mineral ] + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_kept_' + self . Minerals [ mineral ] + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close ()","title":"cube_masking_keep()"},{"location":"examples.html#marcia.mask.Mask.cube_masking_remove","text":"Recreates a raw datacube containing all the data without the mask not wanted. Parameters: Name Type Description Default mineral str Name of the wanted mask (eg: 'Galene') required Source code in marcia/mask.py def cube_masking_remove ( self , mineral : str ): \"\"\" Recreates a raw datacube containing all the data without the mask not wanted. Args: mineral : Name of the wanted mask (eg: 'Galene') \"\"\" # Conversion of given string indices to integer indice of the cube if mineral == 'mixed' : a = self . create_mineral_mask ()[ 0 ] mixed = np . where ( a < np . nanmax ( a ), np . nan , a ) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isfinite ( mixed )] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_removed_mixed' + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_removed_mixed' + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close () elif mineral == 'not indexed' : a = self . create_mineral_mask ()[ 0 ] nan = np . where ( np . isnan ( a ), 0 , a ) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isfinite ( nan )] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_removed_nan' + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_removed_nan' + + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close () else : mineral = list ( self . Minerals . values ()) . index ( str ( mineral )) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isfinite ( self . mineral_cube [:, :, mineral ])] = 0 cube = hs . signals . Signal1D ( array ) cube . save ( self . prefix [: - 1 ] + '_mask_removed_' + self . Minerals [ mineral ] + \".rpl\" , encoding = 'utf8' ) f = open ( self . prefix [: - 1 ] + \".rpl\" , \"r\" ) output = open ( self . prefix [: - 1 ] + '_mask_removed_' + self . Minerals [ mineral ] + \".rpl\" , 'w' ) output . write ( f . read ()) f . close () output . close ()","title":"cube_masking_remove()"},{"location":"examples.html#marcia.mask.Mask.datacube_creation","text":"Create a 3D array (X and Y are the dimensions of the sample and Z dimension is the number of elements/emission lines taken into account for the classification) It stacks the information contained in the elemental files given ranked according to the spreasheet ranking. If the normalization is asked or if the elemental map is an image, the data in the array are between 0 and 100. If there is a scalebar, the corresponding pixels are non assigned.","title":"datacube_creation()"},{"location":"examples.html#marcia.mask.Mask.datacube_creation--three-types-of-elemental-files-are-accepted","text":"Imges (.bmp of .tif), which are RGB files : each pixel contains 3 values between 0 and 255. The rgb is put into greyscale calculated by the norm 2. Textfile (.txt), which is already the elemental array where the values are the number of counts. Raw file (.rpl), wich is the datacube containing all the spectra for every pixel. The hyperspy library is used to extract the emission lines corresponding to the wanted elements. Textfiles and raw files can be normalized or not, the spreadsheet must be written according to that. The function also creates a dictionnary containing the Z position of the element in the 3D array created. 2 class files created in that function. Source code in marcia/mask.py def datacube_creation ( self ): \"\"\" Create a 3D array (X and Y are the dimensions of the sample and Z dimension is the number of elements/emission lines taken into account for the classification) It stacks the information contained in the elemental files given ranked according to the spreasheet ranking. If the normalization is asked or if the elemental map is an image, the data in the array are between 0 and 100. If there is a scalebar, the corresponding pixels are non assigned. Three types of elemental files are accepted ------------------------------------------- - Imges (.bmp of .tif), which are RGB files : each pixel contains 3 values between 0 and 255. The rgb is put into greyscale calculated by the norm 2. - Textfile (.txt), which is already the elemental array where the values are the number of counts. - Raw file (.rpl), wich is the datacube containing all the spectra for every pixel. The hyperspy library is used to extract the emission lines corresponding to the wanted elements. Textfiles and raw files can be normalized or not, the spreadsheet must be written according to that. The function also creates a dictionnary containing the Z position of the element in the 3D array created. 2 class files created in that function. \"\"\" # Check if the data files are images if self . suffix in ( '.bmp' , '.tif' , '.jpg' , '.png' ): # Set automatic normalization to True self . normalization = True # Creation of element names dictionnary self . Elements = {} # Read the first image to know the dimensions test_image = np . linalg . norm ( imread ( self . prefix + self . table . iloc [ 0 ][ 0 ] + self . suffix ), axis = 2 ) self . data_cube = np . zeros ( ( test_image . shape [ 0 ], test_image . shape [ 1 ], self . table . shape [ 0 ])) test_image [:, :] = 0 # Loop over elements in the table for element in range ( self . table . shape [ 0 ]): self . Elements [ element ] = self . table . iloc [ element ][ 'Element' ] # Check if the element is not a ratio of two elements if '/' not in self . table . iloc [ element ][ 'Element' ]: # Load of the RGB image and normalization to one component self . data_cube [:, :, element ] = np . linalg . norm ( imread ( self . prefix + self . table . iloc [ element ][ 0 ] + self . suffix ), axis = 2 ) # If the element is actually a ratio of two elements else : # Load of the two images image_over = imread ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 0 ] + self . suffix ) image_under = imread ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 1 ] + self . suffix ) # Normalization of the two images image_over_grey = np . linalg . norm ( image_over , axis = 2 ) image_under_grey = np . linalg . norm ( image_under , axis = 2 ) # Set 0 values to 0.01 in denominator image in order to # avoid division by 0 image_under_grey [ image_under_grey == 0. ] = 0.01 self . data_cube [ :, :, element ] = image_over_grey / image_under_grey # Normalization over 100 to every element of the cube for i in range ( len ( self . Elements )): self . data_cube [:, :, i ] = self . data_cube [ :, :, i ] / np . nanmax ( self . data_cube [:, :, i ]) * 100 # Check if data are textfiles consisting of raw count data per pixel # per energy elif self . suffix == '.txt' : self . Elements = {} # Read the first image to know the dimensions test_image = np . loadtxt ( self . prefix + self . table . iloc [ 0 ][ 0 ] + self . suffix , delimiter = ';' ) self . data_cube = np . zeros ( ( test_image . shape [ 0 ], test_image . shape [ 1 ], self . table . shape [ 0 ])) test_image [:, :] = 0 # Loop over elements in the table for element in range ( self . table . shape [ 0 ]): self . Elements [ element ] = self . table . iloc [ element ][ 'Element' ] # Check if the element is not a ratio of two elements if '/' not in self . table . iloc [ element ][ 'Element' ]: # Load of the data count per element self . data_cube [:, :, element ] = np . loadtxt ( self . prefix + self . table . iloc [ element ][ 0 ] + self . suffix , delimiter = ';' ) # If the element is actually a ratio of two elements else : image_over_grey = np . loadtxt ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 0 ] + self . suffix , delimiter = ';' ) image_under_grey = np . loadtxt ( self . prefix + self . table [ 'Element' ][ element ] . split ( '/' )[ 1 ] + self . suffix , delimiter = ';' ) self . data_cube [ :, :, element ] = image_over_grey / image_under_grey # If user wants to see normalized over 100 data # This option makes impossible intensity comparison over element if self . normalization : for i in range ( len ( self . Elements )): self . data_cube [:, :, i ] = self . data_cube [ :, :, i ] / np . nanmax ( self . data_cube [:, :, i ]) * 100 # Check if data are .rpl file, that is complete datacube # Load of the file using HyperSpy library elif self . suffix == '.rpl' : cube = hs . load ( self . prefix + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) cube . axes_manager [ - 1 ] . name = 'E' cube . axes_manager [ 'E' ] . units = 'keV' cube . axes_manager [ 'E' ] . scale = 0.01 cube . axes_manager [ 'E' ] . offset = - 0.97 self . Elements = {} self . data_cube = np . zeros (( cube . axes_manager . shape [ 1 ], cube . axes_manager . shape [ 0 ], self . table . shape [ 0 ])) for element in range ( self . table . shape [ 0 ]): self . Elements [ element ] = self . table . iloc [ element ][ 'Element' ] if '/' not in self . table . iloc [ element ][ 'Element' ]: cube . set_elements ([ self . table . iloc [ element ][ 'Element' ]]) array = cube . get_lines_intensity () self . data_cube [:, :, element ] = np . asarray ( array [ 0 ]) else : cube . set_elements ( [ self . table [ 'Element' ][ element ] . split ( '/' )[ 0 ]]) array = cube . get_lines_intensity () image_over = np . asarray ( array [ 0 ]) cube . set_elements ( [ self . table [ 'Element' ][ element ] . split ( '/' )[ 1 ]]) array = cube . get_lines_intensity () image_under = np . asarray ( array [ 0 ]) image_under [ image_under == 0. ] = 0.001 self . data_cube [ :, :, element ] = image_over / image_under if self . normalization : for i in range ( len ( self . Elements )): self . data_cube [:, :, i ] = self . data_cube [ :, :, i ] / np . nanmax ( self . data_cube [:, :, i ]) * 100 # Raise Exception to provide valide data type else : raise Exception ( f \" { self . prefix } invalid data type. \" f \"Valid data types are: \" f \".png, .bmp, .tif, .txt or .rpl \" )","title":"Three types of elemental files are accepted"},{"location":"examples.html#marcia.mask.Mask.get_biplot","text":"Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Parameters: Name Type Description Default indicex str Name of the wanted element on x axis (eg: 'Fe'). required indicey str Name of the wanted element on y axis (eg: 'Pb'). required Source code in marcia/mask.py def get_biplot ( self , indicex : str , indicey : str ): \"\"\" Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Args: indicex: Name of the wanted element on x axis (eg: 'Fe'). indicey: Name of the wanted element on y axis (eg: 'Pb'). \"\"\" # Conversion of given string indices to integer indices of the cubes indicex = list ( self . Elements . values ()) . index ( str ( indicex )) indicey = list ( self . Elements . values ()) . index ( str ( indicey )) fig , axes = plt . subplots () # Number of points limited to 100,000 for computationnal time Valuesx = self . data_cube [ :, :, indicex ][ np . isfinite ( self . data_cube [:, :, indicex ])] Valuesy = self . data_cube [ :, :, indicey ][ np . isfinite ( self . data_cube [:, :, indicey ])] data = { 'x' : Valuesx , 'y' : Valuesy } df = pd . DataFrame ( data ) # Limit number of samples to 100,000 if len ( df ) > 100000 : print ( 'Number of points limited to 100000' ) df = df . sample ( n = 100000 ) df = df . reset_index () . drop ( columns = [ 'index' ]) plt . xlim ( 0 , np . max ( Valuesx )) plt . ylim ( 0 , np . max ( Valuesy )) plt . xlabel ( str ( self . Elements [ indicex ])) plt . ylabel ( str ( self . Elements [ indicey ])) sns . scatterplot ( x = df . x , y = df . y , alpha = 0.3 , marker = \"+\" ) fig . tight_layout () plt . show ()","title":"get_biplot()"},{"location":"examples.html#marcia.mask.Mask.get_hist","text":"Plot the elemental map on the left side an the corresponding hitogram of intensity on the right side Input is the index of the element in the 3D array Useful function in order to set the threshold in the spreadsheet. Parameters: Name Type Description Default indice str Name of the wanted element (eg: 'Fe') required Source code in marcia/mask.py def get_hist ( self , indice : str ): \"\"\" Plot the elemental map on the left side an the corresponding hitogram of intensity on the right side Input is the index of the element in the 3D array Useful function in order to set the threshold in the spreadsheet. Args: indice: Name of the wanted element (eg: 'Fe') \"\"\" # Conversion of given string indices to integer indice of the cube indice = list ( self . Elements . values ()) . index ( str ( indice )) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 5 )) ax = axes . ravel () # Keep only finite values finite_data = self . data_cube [:, :, indice ][ np . isfinite ( self . data_cube [:, :, indice ])] im = ax [ 0 ] . imshow ( self . data_cube [:, :, indice ]) ax [ 0 ] . grid () ax [ 0 ] . set_title ( \"Carte \u00e9l\u00e9mentaire : \" + self . Elements [ indice ]) fig . colorbar ( im , ax = ax [ 0 ]) plt . ylim ( 0 , np . max ( finite_data )) sns . distplot ( finite_data , kde = False , ax = axes [ 1 ], hist_kws = { 'range' : ( 0.0 , np . max ( finite_data ))}, vertical = True ) # Logarithm scale because background has a lof ot points and flatten # interesting information if linear ax [ 1 ] . set_xscale ( 'log' ) ax [ 1 ] . set_title ( \"Histograme d'intensit\u00e9 : \" + self . Elements [ indice ]) fig . tight_layout () plt . show ()","title":"get_hist()"},{"location":"examples.html#marcia.mask.Mask.get_mask","text":"Plot the mineral mask wanted Input is the index of the mineral in the 3D array (cube). Parameters: Name Type Description Default indice str Name of the wanted mask (eg: 'Galene'). required Source code in marcia/mask.py def get_mask ( self , indice : str ): \"\"\" Plot the mineral mask wanted Input is the index of the mineral in the 3D array (cube). Args: indice: Name of the wanted mask (eg: 'Galene'). \"\"\" # Conversion of given string indices to integer indice of the cube indice = list ( self . Minerals . values ()) . index ( str ( indice )) fig = plt . figure () plt . imshow ( self . mineral_cube [:, :, indice ]) plt . title ( self . Minerals [ indice ]) plt . grid () plt . show ()","title":"get_mask()"},{"location":"examples.html#marcia.mask.Mask.get_masked_element","text":"Plot the elemental map and the histogram associated only in a specific mask. Parameters: Name Type Description Default element str Name of the wanted element (eg: 'Fe'). required mineral str Name of the wanted mask (eg: 'Galene'). required Source code in marcia/mask.py def get_masked_element ( self , element : str , mineral : str ): \"\"\" Plot the elemental map and the histogram associated only in a specific mask. Args: element: Name of the wanted element (eg: 'Fe'). mineral: Name of the wanted mask (eg: 'Galene'). \"\"\" # Conversion of given string indices to integer indices of the cubes element = list ( self . Elements . values ()) . index ( str ( element )) mineral = list ( self . Minerals . values ()) . index ( str ( mineral )) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 5 )) ax = axes . ravel () Anan = self . data_cube [:, :, element ][ np . isfinite ( self . data_cube [:, :, element ])] array = self . data_cube [:, :, element ] array [ np . isnan ( self . mineral_cube [:, :, mineral ])] = 0 im = ax [ 0 ] . imshow ( array ) ax [ 0 ] . grid () ax [ 0 ] . set_title ( \"Carte \u00e9l\u00e9mentaire de {} masqu\u00e9\u00e9 par {} \" . format ( self . Elements [ element ], self . Minerals [ mineral ])) fig . colorbar ( im , ax = ax [ 0 ]) plt . ylim ( 0 , np . max ( Anan )) sns . distplot ( Anan , kde = False , ax = axes [ 1 ], hist_kws = { 'range' : ( 0.0 , np . max ( Anan ))}, vertical = True ) ax [ 1 ] . set_xscale ( 'log' ) ax [ 1 ] . set_title ( \"Histograme d'intensit\u00e9 : \" + self . Elements [ element ]) fig . tight_layout () plt . show ()","title":"get_masked_element()"},{"location":"examples.html#marcia.mask.Mask.get_triplot","text":"Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Parameters: Name Type Description Default indicex str Name of the wanted element on x axis(eg: 'Fe'). required indicey str Name of the wanted element on y axis (eg: 'Pb'). required indicez str Name of the wanted element on colorscale (eg: 'Cu'). required Source code in marcia/mask.py def get_triplot ( self , indicex : str , indicey : str , indicez : str ): \"\"\" Plot one element against another one in a scatter plot Input is the indexes of each of the two element in the 3D array Useful function in order to see elemental ratios and some elemental thresholds. Args: indicex: Name of the wanted element on x axis(eg: 'Fe'). indicey: Name of the wanted element on y axis (eg: 'Pb'). indicez: Name of the wanted element on colorscale (eg: 'Cu'). \"\"\" # Conversion of given string indices to integer indices of the cubes indicex = list ( self . Elements . values ()) . index ( str ( indicex )) indicey = list ( self . Elements . values ()) . index ( str ( indicey )) indicez = list ( self . Elements . values ()) . index ( str ( indicez )) fig , axes = plt . subplots () Valuesx = self . data_cube [ :, :, indicex ][ np . isfinite ( self . data_cube [:, :, indicex ])] Valuesy = self . data_cube [ :, :, indicey ][ np . isfinite ( self . data_cube [:, :, indicey ])] Valuesz = self . data_cube [ :, :, indicez ][ np . isfinite ( self . data_cube [:, :, indicez ])] data = { 'x' : Valuesx , 'y' : Valuesy , 'z' : Valuesz } df = pd . DataFrame ( data ) if len ( df ) > 100000 : print ( 'Number of points limited to 100000' ) df = df . sample ( n = 100000 ) df = df . reset_index () . drop ( columns = [ 'index' ]) plt . xlim ( 0 , np . max ( Valuesx )) plt . ylim ( 0 , np . max ( Valuesy )) plt . title ( str ( self . Elements [ indicez ])) sns . scatterplot ( x = df . x , y = df . y , hue = df . z , alpha = 0.3 , marker = \"+\" ) plt . xlabel ( str ( self . Elements [ indicex ])) plt . ylabel ( str ( self . Elements [ indicey ])) fig . tight_layout () plt . show ()","title":"get_triplot()"},{"location":"examples.html#marcia.mask.Mask.load_table","text":"Load the spreadsheet into the programm. Verification if information of colors are required for the classification. Colors are also specified in the spreadsheet. Source code in marcia/mask.py def load_table ( self ): \"\"\" Load the spreadsheet into the programm. Verification if information of colors are required for the classification. Colors are also specified in the spreadsheet. \"\"\" # Check if table is csv/txt or xlsx if self . table_name . split ( '.' )[ - 1 ] in ( 'csv' , 'txt' ): self . table = pd . read_csv ( self . table_name ) elif 'xls' in self . table_name . split ( '.' )[ - 1 ]: self . table = pd . read_excel ( self . table_name ) else : raise Exception ( f \" { self . table_name . split ( '.' )[ - 1 ] } \" f \"invalid Table format.\" f \"Valid data types are: .csv, .txt, or .xls \" ) # Check if table has specific colors for the masks if self . table [ 'Element' ] . str . contains ( 'ouleur|olor' ) . any (): indice = np . where ( self . table [ 'Element' ] . str . contains ( 'ouleur|olor' ))[ 0 ][ 0 ] # Creation of dictionnary containing the colors self . colors = {} for coul in range ( 1 , self . table . iloc [ indice ] . shape [ 0 ]): if isinstance ( self . table . iloc [ indice ][ coul ], str ): self . colors [ coul - 1 ] = self . table . iloc [ indice ][ coul ] # For simplicity in the process, color column is then removed self . table = self . table . drop ([ indice ])","title":"load_table()"},{"location":"examples.html#marcia.mask.Mask.mineralcube_creation","text":"Create a 3D numpy array (X and Y are the dimensions of the sample and Z dimension is the number of minerals wanted for the classification). The minerals are defined by the columns in the spreadsheet. The 2D array create per mineral depends on the threshold specified in the spreadsheet. If one value is given, it corresponds to the minimum threshold to be in the mineral. If two values separated by a dash, it corresponds to the range of values for this element to be in the mineral. Given values are outside the range. Each mineral array is binary with 1 where the pixel is in the mineral and NaN (non assigned) where the pixel is not in the mineral. The function also creates a dictionnary containing the Z position of the minerals in the 3D array created. 2 class files created in that function. Source code in marcia/mask.py def mineralcube_creation ( self ): \"\"\" Create a 3D numpy array (X and Y are the dimensions of the sample and Z dimension is the number of minerals wanted for the classification). The minerals are defined by the columns in the spreadsheet. The 2D array create per mineral depends on the threshold specified in the spreadsheet. If one value is given, it corresponds to the minimum threshold to be in the mineral. If two values separated by a dash, it corresponds to the range of values for this element to be in the mineral. Given values are outside the range. Each mineral array is binary with 1 where the pixel is in the mineral and NaN (non assigned) where the pixel is not in the mineral. The function also creates a dictionnary containing the Z position of the minerals in the 3D array created. 2 class files created in that function. \"\"\" # Creation of mineral/mask names dictionnary self . Minerals = {} # Intializing data cube self . mineral_cube = np . zeros (( self . data_cube . shape [ 0 ], self . data_cube . shape [ 1 ], self . table . shape [ 1 ] - 1 )) # Loop over each mask in order to fill the cube and dictionnary for mask in range ( 1 , self . table . shape [ 1 ]): # Extract name of the mask name = self . table . columns [ mask ] # Fill the dictionnary, the key being an integer index self . Minerals [ mask - 1 ] = name # Values are convert to string in order to facilitate later split str_table = self . table [ name ] . astype ( 'str' , copy = True ) # Keeping indices of elements that are used in a mask index_str = np . where ( self . table [ name ] . notnull ())[ 0 ] # Initializing intermediate 3D array mask_i_str = np . zeros (( self . data_cube . shape [ 0 ], self . data_cube . shape [ 1 ], index_str . shape [ 0 ])) # Loop over elements of the mask for k in range ( index_str . shape [ 0 ]): mask_i_str [:, :, k ] = self . data_cube [:, :, index_str [ k ]] # If only one value in the table: it corresponds to minimum # threshold if len ( str_table [ index_str [ k ]] . split ( '-' )) == 1 : threshold_min = float ( str_table [ index_str [ k ]] . split ( '-' )[ 0 ]) threshold_max = None # If more thant one value (should be 2): it corresponds to the # range of accepted values else : threshold_min = float ( str_table [ index_str [ k ]] . split ( '-' )[ 0 ]) threshold_max = float ( str_table [ index_str [ k ]] . split ( '-' )[ 1 ]) # If the value are normalized, the threshold is between 0 and # 1: need to compare to maximum value if self . normalization : mask_i_str [:, :, k ][ mask_i_str [ :, :, k ] < threshold_min * np . nanmax ( mask_i_str [:, :, k ])] = np . nan if threshold_max : mask_i_str [:, :, k ][ mask_i_str [ :, :, k ] > threshold_max * np . nanmax ( mask_i_str [:, :, k ])] = np . nan # Values outside thresholds are nan, and valid values are # set to 1 mask_i_str [ np . isfinite ( mask_i_str )] = 1 # If not normalize, threshold is just the number of counts else : mask_i_str [:, :, k ][ mask_i_str [:, :, k ] < threshold_min ] = np . nan if threshold_max : mask_i_str [:, :, k ][ mask_i_str [:, :, k ] > threshold_max ] = np . nan # Values outside thresholds are nan, and valid values are # set to 1 mask_i_str [ np . isfinite ( mask_i_str )] = 1 # 3D array is stacked mask_i_str = np . nansum ( mask_i_str , axis = 2 ) # Mask correspond to maximum values: ones that satisfied all # conditions mask_i_str [ mask_i_str < np . max ( mask_i_str )] = np . nan # Mask cube 2D slice is filled with 1 where mask is true self . mineral_cube [:, :, mask - 1 ] = mask_i_str / \\ np . nanmax ( mask_i_str )","title":"mineralcube_creation()"},{"location":"examples.html#marcia.mask.Mask.plot_mineral_mask","text":"For mineralogy purposes, valid only if all masks are minerals Plot all the mask onto one picture in order to visualize the classification. Each pixel correspond to only one mineral at the time, if not, it is classified as \"mixed\". Source code in marcia/mask.py def plot_mineral_mask ( self ): \"\"\" For mineralogy purposes, valid only if all masks are minerals Plot all the mask onto one picture in order to visualize the classification. Each pixel correspond to only one mineral at the time, if not, it is classified as \"mixed\". \"\"\" fig = plt . figure () array , proportion = self . _create_mineral_mask_and_prop () # First plot to generate random colors im = plt . imshow ( array , cmap = 'Paired' ) # Store finite values for later purpose finite_values_array = array [ np . isfinite ( array )] # Check if mixed pixels, need to add one more value if np . nansum ( self . mineral_cube , axis = 2 ) . max () > 1 : values = np . arange ( len ( self . Minerals ) + 1 ) else : values = np . arange ( len ( self . Minerals )) colors = [ im . cmap ( im . norm ( value )) for value in values ] plt . close () # Test if colors where specify in the table if self . colors : # If true, specified values are replaced for value in self . colors : colors [ value ] = self . colors [ value ] # Generating the new colormap new_colormap = ListedColormap ( colors ) # Open new figure fig = plt . figure () im = plt . imshow ( array , cmap = new_colormap , vmin = values . min (), vmax = values . max ()) # create a patch for every color # If true, there are mixed pixels: need to add a patch of mixte if np . nanmax ( array ) > len ( self . Minerals ): patches = [ mpatches . Patch ( color = colors [ np . where ( values == int ( i ))[ 0 ][ 0 ]], label = \" {} : {} %\" . format ( self . Minerals [ int ( i )], str ( round ( proportion [ int ( i )], 2 )))) for i in values [ : - 1 ] if round ( proportion [ int ( i )], 2 ) > 0 ] patches . append ( mpatches . Patch ( color = colors [ - 1 ], label = \" {} : {} %\" . format ( 'Misclassified' , str ( round ( np . where ( array == np . nanmax ( array ))[ 0 ] . shape [ 0 ] / np . sum ( np . isfinite ( array )) * 100 , 2 ))))) # If False, just add patches of corresponding masks else : patches = [ mpatches . Patch ( color = colors [ np . where ( values == int ( i ))[ 0 ][ 0 ]], label = \" {} : {} %\" . format ( self . Minerals [ int ( i )], str ( round ( proportion [ int ( i )], 2 )))) for i in values [:] if round ( proportion [ int ( i )], 2 ) > 0 ] # Finally add a patch to specify proporty of non-classified pixel # Two reasons : images is bigger than sample or misclassification patches . append ( mpatches . Patch ( color = 'white' , label = \" {} : {} %\" . format ( 'Not classified' , str ( round ( ( self . data_cube . shape [ 0 ] * self . data_cube . shape [ 1 ] - len ( finite_values_array )) / ( self . data_cube . shape [ 0 ] * self . data_cube . shape [ 1 ]) * 100 , 2 ))))) # Add patches to the legend plt . legend ( handles = patches , bbox_to_anchor = ( 1.05 , 1 ), loc = 2 , borderaxespad = 0. ) plt . grid ( True ) plt . title ( \"Mineralogical classification - \" + self . prefix [: - 1 ]) plt . tight_layout () plt . show ()","title":"plot_mineral_mask()"},{"location":"examples.html#marcia.mask.Mask.save_mask","text":"Save the mineral mask wanted as a .tif file. Input is the index of the mineral in the 3D array (cube). Parameters: Name Type Description Default indice str Name of the wanted element (eg: 'Fe') required Source code in marcia/mask.py def save_mask ( self , indice : str , raw : bool = False ): \"\"\" Save the mineral mask wanted as a .tif file. Input is the index of the mineral in the 3D array (cube). Args: indice: Name of the wanted element (eg: 'Fe') \"\"\" indice = list ( self . Minerals . values ()) . index ( str ( indice )) if not raw : # Conversion of given string indices to integer indice of the cube plt . imshow ( self . mineral_cube [:, :, indice ]) plt . title ( self . Minerals [ indice ]) plt . savefig ( 'Mask_' + self . Minerals [ indice ] + '.tif' ) plt . close () else : test_array = ( self . mineral_cube [ :, :, indice ] * 255 ) . astype ( np . uint8 ) image = Image . fromarray ( test_array ) image . save ( 'Mask_' + self . Minerals [ indice ] + '.tif' )","title":"save_mask()"},{"location":"examples.html#marcia.mask.Mask.save_mask_spectrum","text":"Save the mean spectrum of a given mask as a txt file First column is channel Second column is counts Parameters: Name Type Description Default mask str Name of the wanted mask (eg: 'Galene') required Source code in marcia/mask.py def save_mask_spectrum ( self , mask : str ): \"\"\"Save the mean spectrum of a given mask as a txt file First column is channel Second column is counts Args: mask: Name of the wanted mask (eg: 'Galene') \"\"\" mineral = list ( self . Minerals . values ()) . index ( str ( mask )) cube = hs . load ( self . prefix [: - 1 ] + \".rpl\" , signal_type = \"EDS_SEM\" , lazy = True ) array = np . asarray ( cube ) array [ np . isnan ( self . mineral_cube [:, :, mineral ])] = 0 cube = hs . signals . Signal1D ( array ) spectrum = cube . sum () . data d = { 'Counts' : spectrum } dataframe = pd . DataFrame ( data = d ) dataframe . index . name = 'channel' dataframe . to_csv ( mask + '_mean_spectrum.txt' )","title":"save_mask_spectrum()"},{"location":"test.html","text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph > img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=\"rtl\"] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } pre { line-height: 125%; } td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; } span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; } td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight-ipynb .hll { background-color: #ffffcc } .highlight-ipynb { background: #f8f8f8; } .highlight-ipynb .c { color: #408080; font-style: italic } /* Comment */ .highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */ .highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */ .highlight-ipynb .o { color: #666666 } /* Operator */ .highlight-ipynb .ch { color: #408080; font-style: italic } /* Comment.Hashbang */ .highlight-ipynb .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight-ipynb .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight-ipynb .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */ .highlight-ipynb .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight-ipynb .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */ .highlight-ipynb .ge { font-style: italic } /* Generic.Emph */ .highlight-ipynb .gr { color: #FF0000 } /* Generic.Error */ .highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight-ipynb .gi { color: #00A000 } /* Generic.Inserted */ .highlight-ipynb .go { color: #888888 } /* Generic.Output */ .highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */ .highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */ .highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */ .highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */ .highlight-ipynb .m { color: #666666 } /* Literal.Number */ .highlight-ipynb .s { color: #BA2121 } /* Literal.String */ .highlight-ipynb .na { color: #7D9029 } /* Name.Attribute */ .highlight-ipynb .nb { color: #008000 } /* Name.Builtin */ .highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight-ipynb .no { color: #880000 } /* Name.Constant */ .highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */ .highlight-ipynb .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight-ipynb .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight-ipynb .nf { color: #0000FF } /* Name.Function */ .highlight-ipynb .nl { color: #A0A000 } /* Name.Label */ .highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight-ipynb .nv { color: #19177C } /* Name.Variable */ .highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */ .highlight-ipynb .mb { color: #666666 } /* Literal.Number.Bin */ .highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */ .highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */ .highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */ .highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */ .highlight-ipynb .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */ .highlight-ipynb .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight-ipynb .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight-ipynb .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */ .highlight-ipynb .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */ .highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight-ipynb .fm { color: #0000FF } /* Name.Function.Magic */ .highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */ .highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */ .highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */ .highlight-ipynb .vm { color: #19177C } /* Name.Variable.Magic */ .highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */ .rendered_html a{text-decoration:inherit !important}.rendered_html :link{text-decoration:inherit !important}.rendered_html :visited{text-decoration:inherit !important}pre code{background-color:inherit !important}.highlight{color:#000000}.highlight code{color:#000000}.highlight .n{color:#333333}.highlight .p{color:#000000}.text_cell .prompt{display:none !important}div.input_prompt{padding:0.2em 0.4em}div.output_prompt{padding:0.4em}.text_cell{margin:0 !important;padding:0 !important;border:none !important}.text_cell_render{margin:0 !important;padding:0 !important;border:none !important}.rendered_html *+p{margin-top:inherit !important}.anchor-link{display:none !important}.code_cell{margin:0 !important;padding:5px 0 !important;border:none !important}.celltoolbar{border:thin solid #CFCFCF;border-bottom:none;background:#EEE;border-radius:2px 2px 0px 0px;width:100%;height:29px;padding-right:4px;box-orient:horizontal;box-align:stretch;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;box-pack:end;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;display:-webkit-flex}.celltoolbar .tags_button_container{display:-webkit-box;display:-ms-flexbox;display:flex}.celltoolbar .tags_button_container .tag-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;position:relative}.celltoolbar .tags_button_container .tag-container .cell-tag{background-color:#fff;white-space:nowrap;margin:3px 4px;padding:0 4px;border-radius:1px;border:1px solid #ccc;-webkit-box-shadow:none;box-shadow:none;width:inherit;font-size:13px;font-family:\"Helvetica Neue\", Helvetica, Arial, sans-serif;height:22px;line-height:22px;display:inline-block}div.input_area>div.highlight{margin:0.25em 0.4em !important}.code_cell pre{font-size:12px !important}.output_html table.dataframe{font-family:Arial, sans-serif;font-size:13px;line-height:20px}.output_html table.dataframe th,td{padding:4px;text-align:left}.bk-plot-wrapper tbody tr{background:none !important}.bk-plot-wrapper tbody tr:hover{background:none !important} /*# sourceMappingURL=jupyter-fixes.min.css.map */ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ], processEscapes: true, processEnvironments: true }, // Center justify equations in code and markdown cells. Elsewhere // we use CSS to left justify single line equations in code cells. displayAlign: 'center', \"HTML-CSS\": { styles: {'.MathJax_Display': {\"margin\": 0}}, linebreaks: { automatic: true } } }); zefdzed In [ ]:","title":"Test"},{"location":"examples/Tutorial.html","text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph > img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=\"rtl\"] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } pre { line-height: 125%; } td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; } span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; } td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight-ipynb .hll { background-color: #ffffcc } .highlight-ipynb { background: #f8f8f8; } .highlight-ipynb .c { color: #408080; font-style: italic } /* Comment */ .highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */ .highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */ .highlight-ipynb .o { color: #666666 } /* Operator */ .highlight-ipynb .ch { color: #408080; font-style: italic } /* Comment.Hashbang */ .highlight-ipynb .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight-ipynb .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight-ipynb .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */ .highlight-ipynb .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight-ipynb .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */ .highlight-ipynb .ge { font-style: italic } /* Generic.Emph */ .highlight-ipynb .gr { color: #FF0000 } /* Generic.Error */ .highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight-ipynb .gi { color: #00A000 } /* Generic.Inserted */ .highlight-ipynb .go { color: #888888 } /* Generic.Output */ .highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */ .highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */ .highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */ .highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */ .highlight-ipynb .m { color: #666666 } /* Literal.Number */ .highlight-ipynb .s { color: #BA2121 } /* Literal.String */ .highlight-ipynb .na { color: #7D9029 } /* Name.Attribute */ .highlight-ipynb .nb { color: #008000 } /* Name.Builtin */ .highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight-ipynb .no { color: #880000 } /* Name.Constant */ .highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */ .highlight-ipynb .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight-ipynb .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight-ipynb .nf { color: #0000FF } /* Name.Function */ .highlight-ipynb .nl { color: #A0A000 } /* Name.Label */ .highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight-ipynb .nv { color: #19177C } /* Name.Variable */ .highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */ .highlight-ipynb .mb { color: #666666 } /* Literal.Number.Bin */ .highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */ .highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */ .highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */ .highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */ .highlight-ipynb .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */ .highlight-ipynb .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight-ipynb .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight-ipynb .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */ .highlight-ipynb .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */ .highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight-ipynb .fm { color: #0000FF } /* Name.Function.Magic */ .highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */ .highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */ .highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */ .highlight-ipynb .vm { color: #19177C } /* Name.Variable.Magic */ .highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */ .rendered_html a{text-decoration:inherit !important}.rendered_html :link{text-decoration:inherit !important}.rendered_html :visited{text-decoration:inherit !important}pre code{background-color:inherit !important}.highlight{color:#000000}.highlight code{color:#000000}.highlight .n{color:#333333}.highlight .p{color:#000000}.text_cell .prompt{display:none !important}div.input_prompt{padding:0.2em 0.4em}div.output_prompt{padding:0.4em}.text_cell{margin:0 !important;padding:0 !important;border:none !important}.text_cell_render{margin:0 !important;padding:0 !important;border:none !important}.rendered_html *+p{margin-top:inherit !important}.anchor-link{display:none !important}.code_cell{margin:0 !important;padding:5px 0 !important;border:none !important}.celltoolbar{border:thin solid #CFCFCF;border-bottom:none;background:#EEE;border-radius:2px 2px 0px 0px;width:100%;height:29px;padding-right:4px;box-orient:horizontal;box-align:stretch;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;box-pack:end;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;display:-webkit-flex}.celltoolbar .tags_button_container{display:-webkit-box;display:-ms-flexbox;display:flex}.celltoolbar .tags_button_container .tag-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;position:relative}.celltoolbar .tags_button_container .tag-container .cell-tag{background-color:#fff;white-space:nowrap;margin:3px 4px;padding:0 4px;border-radius:1px;border:1px solid #ccc;-webkit-box-shadow:none;box-shadow:none;width:inherit;font-size:13px;font-family:\"Helvetica Neue\", Helvetica, Arial, sans-serif;height:22px;line-height:22px;display:inline-block}div.input_area>div.highlight{margin:0.25em 0.4em !important}.code_cell pre{font-size:12px !important}.output_html table.dataframe{font-family:Arial, sans-serif;font-size:13px;line-height:20px}.output_html table.dataframe th,td{padding:4px;text-align:left}.bk-plot-wrapper tbody tr{background:none !important}.bk-plot-wrapper tbody tr:hover{background:none !important} /*# sourceMappingURL=jupyter-fixes.min.css.map */ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ], processEscapes: true, processEnvironments: true }, // Center justify equations in code and markdown cells. Elsewhere // we use CSS to left justify single line equations in code cells. displayAlign: 'center', \"HTML-CSS\": { styles: {'.MathJax_Display': {\"margin\": 0}}, linebreaks: { automatic: true } } }); Utilisation du programme de classification et de masques \u00b6 Cette page montre comment cr\u00e9er des masques \u00e0 partir de cartes \u00e9l\u00e9mentaires afin de r\u00e9aliser une classification min\u00e9ralogique : Ce programme requiert : Numpy ( https://numpy.org ) Pandas ( https://pandas.pydata.org ) Scikit Image ( https://scikit-image.org ) Matplotlib ( https://matplotlib.org ) Seaborn ( https://seaborn.pydata.org ) Hyperspy ( https://hyperspy.org ) Auteur : \u00b6 Hadrien Meyer (ENSG Nancy) Fichiers n\u00e9cessaires : \u00b6 Les donn\u00e9es \u00e9l\u00e9mentaires. Il peut s'agir de cartes \u00e9l\u00e9mentaires (.bmp ou .tif), mais aussi des cartes des donn\u00e9es brutes (.txt) ou encore du cube complet (.raw et du fichier annexe .rpl) Figure 1 : Exemple de carte \u00e9l\u00e9mentaire : Fer. La carte est un fichier de type bitmap (.bmp), c'est-\u00e0-dire qu'elle ne contient plus les informations du nombre de coups par \u00e9nergies. Ellec contient cependant des informations de couleur : 3 nombres entre 0 et 255 par pixels correspondant aux intensit\u00e9s RVB. Un tableur constitu\u00e9 d'une colonne Element et de colonnes portant le nom des masques souhait\u00e9s. Figure 2 : Tableur utilis\u00e9 pour r\u00e9alis\u00e9 la classification Les \u00e9l\u00e9ments indiqu\u00e9s doivent \u00eatre disponibles sous forme de cartes \u00e9lementaires dans le dossier. Un rapport de deux images peut \u00e9galement \u00eatre introduit : ici F3 et F4 correspondent aux pics de diffusion \u00e9lastique (Rayleigh diffusion) et diffusion in\u00e9lastique (Compton). Une couleur peut \u00e9galement \u00eatre sp\u00e9cifi\u00e9e lors de la cr\u00e9ation de la carte min\u00e9ralogique compl\u00e8te. Les couleurs sp\u00e9cifi\u00e9es doivent faire partie de la librairie matplotlib : https://matplotlib.org/3.1.0/gallery/color/named_colors.html Les informations \u00e0 rentrer dans chaque cellule correspondent soit : \u00b6 \u00e0 une valeur comprise entre 0 et 1 si la carte utilis\u00e9e est un fichier .bmp ou .tif. \u00e0 une valeur correspondant \u00e0 un nombre de coups si la carte utilis\u00e9e est un fichier .txt ou .raw (et .rpl associ\u00e9e) et que l'utilisateur souhaite travailler avec les valeurs en nombres de coups. Il peut cependant aussi travailler avec des valeurs comprises entre 0 et 1. Quelles types de valeurs entrer \u00b6 Il peut s'agir d'un seul nombre. Si c'est un nombre \u00e0 virgule, la s\u00e9paration se fait par un point. Il peut s'agir d'une plage de valeurs ou les deux nombres sont s\u00e9par\u00e9s par un tiret (dash). Comment utiliser le programme \u00b6 Dans un premier temps on ouvre un script python, ou une session via un terminal. Il faut ensuite importer le programme suivant (il doit se trouver dans le m\u00eame dossier que les cartes \u00e9l\u00e9mentaires et que le tableur. In [1]: from marcia.mask import Mask Il faut ensuite cr\u00e9er la classe permettant la classification. Cette \u00e9tape permet de prendre en compte les noms des diff\u00e9rents fichier d'entr\u00e9e. In [2]: cm = Mask ( 'Data/lead_ore_' , '.bmp' , 'Data/Mask.xlsx' ) Il faut maintenant charger le tableur : In [3]: cm . load_table () Il faut maintenant extraire les donn\u00e9es \u00e9l\u00e9mentaires des images. Pour cela on cr\u00e9\u00e9 un cube de donn\u00e9es (3 dimensions) ou les 2 premi\u00e8res dimensions correspondent aux dimensions de l'echantillon (dimensions spatiales) et la troisi\u00e8me dimensions correspond aux informations pour chaque \u00e9l\u00e9ment disponible. c'est comme si les cartes \u00e9l\u00e9mentaires \u00e9taient empil\u00e9es. In [4]: cm . datacube_creation () On obtient ainsi un cube des donn\u00e9es \u00e9l\u00e9mentaires. Pour retrouver l'index de chaque \u00e9l\u00e9ment, il suffit d'afficher le dictionnaire des indexations \u00e9l\u00e9mentaires correspondantes: In [5]: cm . Elements Out[5]: {0: 'Al', 1: 'As', 2: 'Ca', 3: 'Cl', 4: 'Cu', 5: 'Fe', 6: 'K', 7: 'Mg', 8: 'Mn', 9: 'Na', 10: 'Pb', 11: 'S', 12: 'Si', 13: 'Ti'} Ainsi cm.datacube_[:,:,0] correspond \u00e0 la carte \u00e9l\u00e9mentaire de l'aluminium. Une fois ce cube cr\u00e9\u00e9, on peut \u00e9galement afficher la carte \u00e9l\u00e9mentaire avec l'histogramme des intensit\u00e9s. Pour obtenir l'histogramme du plomb (\u00e9l\u00e9ment discriminant de la gal\u00e8ne dans notre \u00e9chantillon), on rentre la commande suivante : In [6]: cm . get_hist ( 'Pb' ) On remarque ainsi que dans l'\u00e9chantillon, il y a une population entre 80% et 100% du pic d'intensit\u00e9, surement correspondant \u00e0 la gal\u00e8ne. Le pic le plus elev\u00e9 d'intensit\u00e9 0 correspond au bruit de fond. Les donn\u00e9es d'entr\u00e9es \u00e9tant des images, les intensit\u00e9s calcul\u00e9es sont ainsi normalis\u00e9es \u00e0 100, o\u00f9 100 correspond au pixel d'intensit\u00e9 maximale de l'\u00e9l\u00e9ment voulu. En connaissant les formules des min\u00e9raux pr\u00e9sents, il est possible de caract\u00e9riser les diff\u00e9rentes populations. La population ayant l'intensit\u00e9 la plus \u00e9lev\u00e9e correspond \u00e0 de la gal\u00e8ne (PbS). Ainsi dans le tableur d'entr\u00e9e, il est possible de sp\u00e9cifier les valeurs du plomb pour la gal\u00e8ne : ici il est difficile de d\u00e9finir une limite basse, on peut ainsi consid\u00e9rer de garder toutes les valeurs au dessus du bruit de fond : 0.05. Si besoin, on pourra affiner cette valeur plus tard dans le tableau. Afin de prendre en compte la modification du tableau, on recharge le tableur : In [7]: cm . load_table () Maitenant que des valeurs ont \u00e9t\u00e9 sp\u00e9cifi\u00e9es pour un min\u00e9ral, on peut \u00e9galement cr\u00e9er le cube des masques min\u00e9ralogiques. Il se pr\u00e9sente sous la m\u00eame forme que celui des \u00e9l\u00e9ments, mais ne poss\u00e8de que des 1 la o\u00f9 le pixel est associ\u00e9 au min\u00e9ral, et n'est pas assign\u00e9 si le pixel n'est pas dans le min\u00e9ral In [8]: cm . mineralcube_creation () De m\u00eame que pour les \u00e9l\u00e9ments, il existe un dictionnaire des min\u00e9raux permettant de retrouver l'index du min\u00e9ral dans le cube cr\u00e9\u00e9 In [9]: cm . Minerals Out[9]: {0: 'Galene', 1: 'Chalcopyrite', 2: 'Siderite', 3: 'Quartz'} Etant donn\u00e9 que seul deux min\u00e9raux ont \u00e9t\u00e9 d\u00e9finis pour l'instant dans le classeur, seul deux masques ont r\u00e9\u00e9llement \u00e9t\u00e9 cr\u00e9\u00e9s. On peut visualiser chaque masque avec la commande suivante : cm.get_mask('nom'). Le nom \u00e9tant celui d\u00e9fini dans le tableur. In [10]: cm . get_mask ( 'Galene' ) Ainsi cm.get_mask('Galene') affiche le masque de la gal\u00e8ne Il est \u00e9galement possible d'afficher la classification min\u00e9ralogique totale sur une seule image : In [11]: cm . plot_mineral_mask () L'image ainsi obtenue montre le min\u00e9ral classifi\u00e9 ainsi que sa proportion. Sont \u00e9galements affich\u00e9s les pixels class\u00e9s dans plusieurs min\u00e9raux et sont appel\u00e9s mixtes. La somme des proportions des min\u00e9raux et des mixtes boucle \u00e0 100%. La proportion de pixels non index\u00e9s sur toute l'images est \u00e9galement affich\u00e9s. Ici, cela montre que 87.2% des pixels n'ont pas encore \u00e9t\u00e9 class\u00e9s et que sur sur les 12.8% class\u00e9s, 100% correspondent \u00e0 de la gal\u00e8ne. En analysant les diff\u00e9rents histogrammes des \u00e9l\u00e9ments on peut r\u00e9aliser des seuils pour les autres min\u00e9raux et r\u00e9aliser une classification compl\u00e8te. Un exempel de remplissage du tableur est present\u00e9 ci-dessous. Il n'est cependant pas unique et est \u00e0 l'appr\u00e9ciation de l'utilisateur qui connait son echantillon et sa min\u00e9ralogie. Ainsi on recharge le tableur In [12]: cm . load_table () On recr\u00e9\u00e9 les masques correspondants In [13]: cm . mineralcube_creation () Et on peut afficher la classification finale In [14]: cm . plot_mineral_mask () On remarque ainsi que l'\u00e9chantillon ne prenant pas toute l'image, il y'a beaucoup de pixels non ind\u00e9x\u00e9s. On remarque \u00e9galement qu'il y a 6.38% des pixels class\u00e9s qui l'ont \u00e9t\u00e9 plus d'une fois : cela veut dire qu'il est n\u00e9cessaire de retravailler les seuils afin d'abaisser le plus possible le pourcentage de mixtes.","title":"Docs"},{"location":"examples/Tutorial.html#utilisation-du-programme-de-classification-et-de-masques","text":"Cette page montre comment cr\u00e9er des masques \u00e0 partir de cartes \u00e9l\u00e9mentaires afin de r\u00e9aliser une classification min\u00e9ralogique : Ce programme requiert : Numpy ( https://numpy.org ) Pandas ( https://pandas.pydata.org ) Scikit Image ( https://scikit-image.org ) Matplotlib ( https://matplotlib.org ) Seaborn ( https://seaborn.pydata.org ) Hyperspy ( https://hyperspy.org )","title":"Utilisation du programme de classification et de masques"},{"location":"examples/Tutorial.html#quelles-types-de-valeurs-entrer","text":"Il peut s'agir d'un seul nombre. Si c'est un nombre \u00e0 virgule, la s\u00e9paration se fait par un point. Il peut s'agir d'une plage de valeurs ou les deux nombres sont s\u00e9par\u00e9s par un tiret (dash).","title":"Quelles types de valeurs entrer"},{"location":"examples/Tutorial.html#comment-utiliser-le-programme","text":"Dans un premier temps on ouvre un script python, ou une session via un terminal. Il faut ensuite importer le programme suivant (il doit se trouver dans le m\u00eame dossier que les cartes \u00e9l\u00e9mentaires et que le tableur. In [1]: from marcia.mask import Mask Il faut ensuite cr\u00e9er la classe permettant la classification. Cette \u00e9tape permet de prendre en compte les noms des diff\u00e9rents fichier d'entr\u00e9e. In [2]: cm = Mask ( 'Data/lead_ore_' , '.bmp' , 'Data/Mask.xlsx' ) Il faut maintenant charger le tableur : In [3]: cm . load_table () Il faut maintenant extraire les donn\u00e9es \u00e9l\u00e9mentaires des images. Pour cela on cr\u00e9\u00e9 un cube de donn\u00e9es (3 dimensions) ou les 2 premi\u00e8res dimensions correspondent aux dimensions de l'echantillon (dimensions spatiales) et la troisi\u00e8me dimensions correspond aux informations pour chaque \u00e9l\u00e9ment disponible. c'est comme si les cartes \u00e9l\u00e9mentaires \u00e9taient empil\u00e9es. In [4]: cm . datacube_creation () On obtient ainsi un cube des donn\u00e9es \u00e9l\u00e9mentaires. Pour retrouver l'index de chaque \u00e9l\u00e9ment, il suffit d'afficher le dictionnaire des indexations \u00e9l\u00e9mentaires correspondantes: In [5]: cm . Elements Out[5]: {0: 'Al', 1: 'As', 2: 'Ca', 3: 'Cl', 4: 'Cu', 5: 'Fe', 6: 'K', 7: 'Mg', 8: 'Mn', 9: 'Na', 10: 'Pb', 11: 'S', 12: 'Si', 13: 'Ti'} Ainsi cm.datacube_[:,:,0] correspond \u00e0 la carte \u00e9l\u00e9mentaire de l'aluminium. Une fois ce cube cr\u00e9\u00e9, on peut \u00e9galement afficher la carte \u00e9l\u00e9mentaire avec l'histogramme des intensit\u00e9s. Pour obtenir l'histogramme du plomb (\u00e9l\u00e9ment discriminant de la gal\u00e8ne dans notre \u00e9chantillon), on rentre la commande suivante : In [6]: cm . get_hist ( 'Pb' ) On remarque ainsi que dans l'\u00e9chantillon, il y a une population entre 80% et 100% du pic d'intensit\u00e9, surement correspondant \u00e0 la gal\u00e8ne. Le pic le plus elev\u00e9 d'intensit\u00e9 0 correspond au bruit de fond. Les donn\u00e9es d'entr\u00e9es \u00e9tant des images, les intensit\u00e9s calcul\u00e9es sont ainsi normalis\u00e9es \u00e0 100, o\u00f9 100 correspond au pixel d'intensit\u00e9 maximale de l'\u00e9l\u00e9ment voulu. En connaissant les formules des min\u00e9raux pr\u00e9sents, il est possible de caract\u00e9riser les diff\u00e9rentes populations. La population ayant l'intensit\u00e9 la plus \u00e9lev\u00e9e correspond \u00e0 de la gal\u00e8ne (PbS). Ainsi dans le tableur d'entr\u00e9e, il est possible de sp\u00e9cifier les valeurs du plomb pour la gal\u00e8ne : ici il est difficile de d\u00e9finir une limite basse, on peut ainsi consid\u00e9rer de garder toutes les valeurs au dessus du bruit de fond : 0.05. Si besoin, on pourra affiner cette valeur plus tard dans le tableau. Afin de prendre en compte la modification du tableau, on recharge le tableur : In [7]: cm . load_table () Maitenant que des valeurs ont \u00e9t\u00e9 sp\u00e9cifi\u00e9es pour un min\u00e9ral, on peut \u00e9galement cr\u00e9er le cube des masques min\u00e9ralogiques. Il se pr\u00e9sente sous la m\u00eame forme que celui des \u00e9l\u00e9ments, mais ne poss\u00e8de que des 1 la o\u00f9 le pixel est associ\u00e9 au min\u00e9ral, et n'est pas assign\u00e9 si le pixel n'est pas dans le min\u00e9ral In [8]: cm . mineralcube_creation () De m\u00eame que pour les \u00e9l\u00e9ments, il existe un dictionnaire des min\u00e9raux permettant de retrouver l'index du min\u00e9ral dans le cube cr\u00e9\u00e9 In [9]: cm . Minerals Out[9]: {0: 'Galene', 1: 'Chalcopyrite', 2: 'Siderite', 3: 'Quartz'} Etant donn\u00e9 que seul deux min\u00e9raux ont \u00e9t\u00e9 d\u00e9finis pour l'instant dans le classeur, seul deux masques ont r\u00e9\u00e9llement \u00e9t\u00e9 cr\u00e9\u00e9s. On peut visualiser chaque masque avec la commande suivante : cm.get_mask('nom'). Le nom \u00e9tant celui d\u00e9fini dans le tableur. In [10]: cm . get_mask ( 'Galene' ) Ainsi cm.get_mask('Galene') affiche le masque de la gal\u00e8ne Il est \u00e9galement possible d'afficher la classification min\u00e9ralogique totale sur une seule image : In [11]: cm . plot_mineral_mask () L'image ainsi obtenue montre le min\u00e9ral classifi\u00e9 ainsi que sa proportion. Sont \u00e9galements affich\u00e9s les pixels class\u00e9s dans plusieurs min\u00e9raux et sont appel\u00e9s mixtes. La somme des proportions des min\u00e9raux et des mixtes boucle \u00e0 100%. La proportion de pixels non index\u00e9s sur toute l'images est \u00e9galement affich\u00e9s. Ici, cela montre que 87.2% des pixels n'ont pas encore \u00e9t\u00e9 class\u00e9s et que sur sur les 12.8% class\u00e9s, 100% correspondent \u00e0 de la gal\u00e8ne. En analysant les diff\u00e9rents histogrammes des \u00e9l\u00e9ments on peut r\u00e9aliser des seuils pour les autres min\u00e9raux et r\u00e9aliser une classification compl\u00e8te. Un exempel de remplissage du tableur est present\u00e9 ci-dessous. Il n'est cependant pas unique et est \u00e0 l'appr\u00e9ciation de l'utilisateur qui connait son echantillon et sa min\u00e9ralogie. Ainsi on recharge le tableur In [12]: cm . load_table () On recr\u00e9\u00e9 les masques correspondants In [13]: cm . mineralcube_creation () Et on peut afficher la classification finale In [14]: cm . plot_mineral_mask () On remarque ainsi que l'\u00e9chantillon ne prenant pas toute l'image, il y'a beaucoup de pixels non ind\u00e9x\u00e9s. On remarque \u00e9galement qu'il y a 6.38% des pixels class\u00e9s qui l'ont \u00e9t\u00e9 plus d'une fois : cela veut dire qu'il est n\u00e9cessaire de retravailler les seuils afin d'abaisser le plus possible le pourcentage de mixtes.","title":"Comment utiliser le programme"}]}